

==== res:///core/ecs/data/attribute_layer.gd ====
# res://core/ecs/data/attribute_layer.gd
class_name AttributeLayer extends Resource

# åŸºç¡€å±æ€§
@export var health: int = 0
@export var mana: int = 0

# æ”»å‡»å±æ€§
@export var min_attack: int = 0
@export var max_attack: int = 0
@export var min_magic_attack: int = 0    # æœ€å°é­”æ³•æ”»å‡»
@export var max_magic_attack: int = 0    # æœ€å¤§é­”æ³•æ”»å‡»

# é˜²å¾¡å±æ€§
@export var min_defense: int = 0
@export var max_defense: int = 0
@export var min_magic_defense: int = 0
@export var max_magic_defense: int = 0

# ç‰¹æ®Šå±æ€§
@export var accuracy: int = 0      # å‡†ç¡®
@export var agility: int = 0       # æ•æ·
@export var luck: int = 0          # å¹¸è¿
@export var curse: int = 0         # è¯…å’’

# éšè—å±æ€§
@export var magic_dodge: float = 0.0    # é­”æ³•èº²é¿
@export var critical_rate: float = 0.0  # æš´å‡»ç‡
@export var attack_speed: float = 1.0   # æ”»å‡»é€Ÿåº¦

# åºåˆ—åŒ–
func serialize() -> Dictionary:
	return {
		"health": health,
		"mana": mana,
		"min_attack": min_attack,
		"max_attack": max_attack,
		"min_magic_attack": min_magic_attack,
		"max_magic_attack": max_magic_attack,
		
		"min_defense": min_defense,
		"max_defense": max_defense,
		"min_magic_defense": min_magic_defense,
		"max_magic_defense": max_magic_defense,
		
		"accuracy": accuracy,
		"agility": agility,
		"luck": luck,
		"curse": curse,
		"magic_dodge": magic_dodge,
		"critical_rate": critical_rate,
		"attack_speed": attack_speed
	}

# ååºåˆ—åŒ–
func deserialize(data: Dictionary):
	health = data.get("health", 0)
	mana = data.get("mana", 0)
	min_attack = data.get("min_attack", 0)
	max_attack = data.get("max_attack", 0)
	min_magic_attack = data.get("min_magic_attack", 0)
	max_magic_attack = data.get("max_magic_attack", 0)
	
	min_defense = data.get("min_defense", 0)
	max_defense = data.get("max_defense", 0)
	min_magic_defense = data.get("min_magic_defense", 0)
	max_magic_defense = data.get("max_magic_defense", 0)
	
	accuracy = data.get("accuracy", 0)
	agility = data.get("agility", 0)
	luck = data.get("luck", 0)
	curse = data.get("curse", 0)
	magic_dodge = data.get("magic_dodge", 0.0)
	critical_rate = data.get("critical_rate", 0.0)
	attack_speed = data.get("attack_speed", 1.0)


==== res:///core/ecs/data/combat/combat_attributes_base.gd ====
# res://core/ecs/data/combat/combat_attributes_base.gd
class_name CombatAttributesBase extends Resource

# åŸºç¡€å±æ€§è®¿é—®
func get_health() -> int:
	return 0

func get_mana() -> int:
	return 0

func get_min_attack() -> int:
	return 0

func get_max_attack() -> int:
	return 0

func get_min_magic_attack() -> int:
	return 0

func get_max_magic_attack() -> int:
	return 0
	
func get_min_defense() -> int:
	return 0

func get_max_defense() -> int:
	return 0

func get_min_magic_defense() -> int:
	return 0
	
func get_max_magic_defense() -> int:
	return 0

func get_accuracy() -> int:
	return 0

func get_agility() -> int:
	return 0

func get_luck() -> int:
	return 0

func get_curse() -> int:
	return 0

func get_magic_dodge() -> float:
	return 0

func get_critical_rate() -> float:
	return 0

func get_attack_speed() -> float:
	return 0

# åºåˆ—åŒ–
func serialize() -> Dictionary:
	return {
	}

# ååºåˆ—åŒ–
func deserialize(_data: Dictionary):
	pass

func get_class_name() -> String:
	return "CombatAttributesBase"


==== res:///core/ecs/data/combat/monster_combat_attributes.gd ====
# res://core/ecs/data/combat/monster_combat_attributes.gd
class_name MonsterCombatAttributes extends CombatAttributesBase

@export var base: AttributeLayer = AttributeLayer.new()  # é…è¡¨æ•°æ®
@export var buff: AttributeLayer = AttributeLayer.new()  # BuffåŠ æˆ

# é‡å†™è®¡ç®—æ–¹æ³•ï¼ˆåŸºç¡€ + Buffï¼‰
func get_health() -> int:
	return base.health + buff.health

func get_mana() -> int:
	return base.mana + buff.mana

func get_min_attack() -> int:
	return base.min_attack + buff.min_attack

func get_max_attack() -> int:
	return base.max_attack + buff.max_attack

func get_min_magic_attack() -> int:
	return base.min_magic_attack + buff.min_magic_attack

func get_max_magic_attack() -> int:
	return base.max_magic_attack + buff.max_magic_attack
	
func get_min_defense() -> int:
	return base.min_defense + buff.min_defense

func get_max_defense() -> int:
	return base.max_defense + buff.max_defense

func get_min_magic_defense() -> int:
	return base.min_magic_defense + buff.min_magic_defense
	
func get_max_magic_defense() -> int:
	return base.max_magic_defense + buff.max_magic_defense
	
func get_accuracy() -> int:
	return base.accuracy + buff.accuracy

func get_agility() -> int:
	return base.agility + buff.agility

func get_luck() -> int:
	return base.luck + buff.luck

func get_curse() -> int:
	return base.curse + buff.curse

func get_magic_dodge() -> float:
	return base.magic_dodge + buff.magic_dodge

func get_critical_rate() -> float:
	return base.critical_rate + buff.critical_rate

func get_attack_speed() -> float:
	return base.attack_speed + buff.attack_speed

func get_class_name() -> String:
	return "MonsterCombatAttributes"


==== res:///core/ecs/data/combat/npc_combat_attributes.gd ====
# res://core/ecs/data/combat/npc_combat_attributes.gd
class_name NPCCombatAttributes extends CombatAttributesBase
# NPCåªéœ€è¦åŸºç¡€å±‚ï¼Œä¸éœ€è¦é‡å†™ä»»ä½•æ–¹æ³•
# æˆ–è€…å¦‚æœNPCå®Œå…¨æ²¡æœ‰æˆ˜æ–—å±æ€§ï¼Œå¯ä»¥å®Œå…¨ä¸ç”¨è¿™ä¸ªç±»


==== res:///core/ecs/data/combat/player_combat_attributes.gd ====
# res://core/ecs/data/combat/player_combat_attributes.gd
class_name PlayerCombatAttributes extends CombatAttributesBase

@export var job: AttributeLayer = AttributeLayer.new()       # èŒä¸šåŸºç¡€æ•°æ®
@export var level: AttributeLayer = AttributeLayer.new()     # ç­‰çº§åŠ æˆ
@export var equipment: AttributeLayer = AttributeLayer.new() # è£…å¤‡åŠ æˆ  
@export var buff: AttributeLayer = AttributeLayer.new()      # BuffåŠ æˆ
@export var passive: AttributeLayer = AttributeLayer.new()   # ğŸ†• è¢«åŠ¨æŠ€èƒ½åŠ æˆ

# è®¡ç®—æ–¹æ³•ï¼ˆèŒä¸šåŸºç¡€ + ç­‰çº§ + è£…å¤‡ + Buff + è¢«åŠ¨æŠ€èƒ½ï¼‰
func get_health() -> int:
	return job.health + level.health + equipment.health + buff.health + passive.health

func get_mana() -> int:
	return job.mana + level.mana + equipment.mana + buff.mana + passive.mana

func get_min_attack() -> int:
	return job.min_attack + level.min_attack + equipment.min_attack + buff.min_attack + passive.min_attack

func get_max_attack() -> int:
	return job.max_attack + level.max_attack + equipment.max_attack + buff.max_attack + passive.max_attack

func get_min_magic_attack() -> int:
	return job.min_magic_attack + level.min_magic_attack + equipment.min_magic_attack + buff.min_magic_attack + passive.min_magic_attack

func get_max_magic_attack() -> int:
	return job.max_magic_attack + level.max_magic_attack + equipment.max_magic_attack + buff.max_magic_attack + passive.max_magic_attack
	
func get_min_defense() -> int:
	return job.min_defense + level.min_defense + equipment.min_defense + buff.min_defense + passive.min_defense

func get_max_defense() -> int:
	return job.max_defense + level.max_defense + equipment.max_defense + buff.max_defense + passive.max_defense

func get_min_magic_defense() -> int:
	return job.min_magic_defense + level.min_magic_defense + equipment.min_magic_defense + buff.min_magic_defense + passive.min_magic_defense
	
func get_max_magic_defense() -> int:
	return job.max_magic_defense + level.max_magic_defense + equipment.max_magic_defense + buff.max_magic_defense + passive.max_magic_defense
	
func get_accuracy() -> int:
	return job.accuracy + level.accuracy + equipment.accuracy + buff.accuracy + passive.accuracy

func get_agility() -> int:
	return job.agility + level.agility + equipment.agility + buff.agility + passive.agility

func get_luck() -> int:
	return job.luck + level.luck + equipment.luck + buff.luck + passive.luck

func get_curse() -> int:
	return job.curse + level.curse + equipment.curse + buff.curse + passive.curse

func get_magic_dodge() -> float:
	return job.magic_dodge + level.magic_dodge + equipment.magic_dodge + buff.magic_dodge + passive.magic_dodge

func get_critical_rate() -> float:
	return job.critical_rate + level.critical_rate + equipment.critical_rate + buff.critical_rate + passive.critical_rate

func get_attack_speed() -> float:
	return job.attack_speed + level.attack_speed + equipment.attack_speed + buff.attack_speed + passive.attack_speed

# åºåˆ—åŒ–
func serialize() -> Dictionary:
	return {
		"job": job.serialize(),
		"level": level.serialize(),
		"equipment": equipment.serialize(),
		"buff": buff.serialize(),
		"passive": passive.serialize()  # ğŸ†• åºåˆ—åŒ–è¢«åŠ¨æŠ€èƒ½åŠ æˆ
	}

# ååºåˆ—åŒ–
func deserialize(data: Dictionary):
	if data.has("job"): job.deserialize(data["job"])
	if data.has("level"): level.deserialize(data["level"])
	if data.has("equipment"): equipment.deserialize(data["equipment"])
	if data.has("buff"): buff.deserialize(data["buff"])
	if data.has("passive"): passive.deserialize(data["passive"])  # ğŸ†• ååºåˆ—åŒ–è¢«åŠ¨æŠ€èƒ½åŠ æˆ

func get_class_name() -> String:
	return "PlayerCombatAttributes"


==== res:///core/ecs/data/config_data.gd ====
# ä½é¢‘å˜åŒ–çš„é…ç½®æ•°æ®ï¼ˆå¯åŠ¨æ—¶è®¾å®šï¼Œå¾ˆå°‘å˜åŠ¨ï¼‰
class_name ConfigData extends Resource

# åŸºç¡€å±æ€§
var entity_id: String = ""				# å®ä½“å”¯ä¸€ID
var entity_name: String = ""				# æ˜¾ç¤ºåç§°ï¼ˆæ€ªç‰©/NPCç”¨ï¼‰
var entity_type: String = ""				# player, monster, npc, item
var prefab_path: String = ""				# å¯¹åº”çš„åœºæ™¯æ–‡ä»¶è·¯å¾„
# ç§»åŠ¨é€Ÿåº¦é…ç½®ï¼ˆåƒç´ /ç§’ï¼‰
var move_speed: float = 300.0  # é»˜è®¤ç§»åŠ¨é€Ÿåº¦

# æŠ€èƒ½å’Œè£…å¤‡é…ç½®
var skills: Array[String] = []
var equipment_slots: Array[String] = []

# è§†è§‰å’Œè¡¨ç°
var sprite_path: String = ""
var scale: Vector2 = Vector2.ONE

# === ç©å®¶ç‰¹æœ‰é…ç½® ===
var character_class: String = "warrior" # warrior, mage, taoist
var gender: String = "male"             # male, female

# === æ€ªç‰©ç‰¹æœ‰é…ç½® ===
var ai_behavior: String = "passive"     # passive, aggressive, neutral
var monster_rank: String = "normal"     # normal, elite, boss, lord

# === è£…å¤‡æ§½ä½é…ç½® ===
var equip_slots: Array[String] = [
	"weapon", "helmet", "necklace", "armor", 
	"bracelet", "ring", "boots"
]

# æ„é€ å‡½æ•°
func _init(
	id: String = "", 
	name: String = "", 
	type: String = "player", 
	char_class: String = "warrior",
	speed:float = 300.0
):
	entity_id = id
	entity_name = name
	entity_type = type
	character_class = char_class
	move_speed = 3000.0
	
# === å·¥å…·æ–¹æ³• ===
func get_class_display_name() -> String:
	match character_class:
		"warrior": return "æˆ˜å£«"
		"mage": return "æ³•å¸ˆ"
		"taoist": return "é“å£«"
		_: return "æœªçŸ¥èŒä¸š"
		
# æ€ªç‰©ç›¸å…³æ–¹æ³•
func is_monster() -> bool:
	return entity_type == "monster"

func is_player() -> bool:
	return entity_type == "player"

func is_npc() -> bool:
	return entity_type == "npc"

# è·å–è¡Œä¸ºæ¨¡å¼æ˜¾ç¤ºåç§°
func get_behavior_display_name() -> String:
	match ai_behavior:
		"passive": return "è¢«åŠ¨"
		"aggressive": return "ä¸»åŠ¨"
		"neutral": return "ä¸­ç«‹"
		"fleeing": return "é€ƒè·‘"
		_: return "æœªçŸ¥"

# è·å–æ€ªç‰©ç­‰çº§æ˜¾ç¤ºåç§°
func get_rank_display_name() -> String:
	match monster_rank:
		"normal": return "æ™®é€š"
		"elite": return "ç²¾è‹±"
		"boss": return "é¦–é¢†"
		"lord": return "é¢†ä¸»"
		_: return "æœªçŸ¥"
		
func get_display_name() -> String:
	return "%s Lv.1 %s" % [entity_name, get_class_display_name()]

func has_skill(skill_id: String) -> bool:
	return skill_id in skills

func add_skill(skill_id: String) -> void:
	if not has_skill(skill_id):
		skills.append(skill_id)
	


==== res:///core/ecs/data/entity_data.gd ====
# ç»Ÿä¸€æ•°æ®ç®¡ç†å®¹å™¨ï¼Œæ”¯æŒå“åº”å¼æ•°æ®å˜æ›´
class_name EntityData extends Resource

# æ•°æ®ç»„ä»¶å¼•ç”¨
var runtime: RuntimeData = null
var config: ConfigData = null

# === æ•°æ®å˜æ›´ä¿¡å· ===
signal data_changed(property_name: String, old_value, new_value)
signal position_changed(old_pos: Vector2, new_pos: Vector2)
signal health_changed(old_health: int, new_health: int)
signal mana_changed(old_mana: int, new_mana: int)

# æ„é€ å‡½æ•°
func _init(
	runtime_data: RuntimeData = null, 
	config_data: ConfigData = null
):
	runtime = runtime_data if runtime_data else RuntimeData.new()
	config = config_data if config_data else ConfigData.new()

# è½¬å‘è¿è¡Œæ—¶ç»„ä»¶å˜æ›´ä¿¡å·
func _on_runtime_data_changed(property: String, old_value, new_value):
	data_changed.emit("runtime", property, old_value, new_value)

# === åŸºç¡€æ•°æ®è®¿é—® ===
func set_position(new_position: Vector2) -> void:
	if runtime.position != new_position:
		var old_position = runtime.position
		runtime.position = new_position
		position_changed.emit(old_position, new_position)

# === çŠ¶æ€æ£€æŸ¥ ===
func is_alive() -> bool:
	return runtime.is_alive()
	
func has_state_flag(state_flag: int) -> bool:
	return runtime.has_state_flag(state_flag)

func set_state_flag(state_flag: int) -> void:
	var old_flags = runtime.state_flags
	runtime.set_state_flag(state_flag)
	if runtime.state_flags != old_flags:
		data_changed.emit("state_flags", old_flags, runtime.state_flags)

func clear_state_flag(state_flag: int) -> void:
	var old_flags = runtime.state_flags
	runtime.clear_state_flag(state_flag)
	if runtime.state_flags != old_flags:
		data_changed.emit("state_flags", old_flags, runtime.state_flags)

func get_active_states() -> Array:
	return runtime.get_active_states()

# === ä¼¤å®³å’Œæ²»ç–— ===
func take_damage(damage: int) -> void:
	var old_health = runtime.current_health
	runtime.take_damage(damage)
	health_changed.emit(old_health, runtime.current_health)

func heal(amount: int) -> void:
	var old_health = runtime.current_health
	runtime.heal(amount)
	health_changed.emit(old_health, runtime.current_health)

# === å·¥å…·æ–¹æ³• ===
func get_display_name() -> String:
	# ä¼˜å…ˆä½¿ç”¨è¿è¡Œæ—¶æ˜µç§°ï¼Œæ²¡æœ‰åˆ™ä½¿ç”¨é…ç½®åç§°
	if runtime.nickname != "":
		return runtime.nickname
	return config.get_display_name()

func get_character_class() -> String:
	return config.character_class

# === æˆ˜æ–—å±æ€§è®¿é—®ï¼ˆå§”æ‰˜ç»™RuntimeDataï¼‰===
func get_position() -> Vector2: return runtime.position
	
func get_level() -> int: return runtime.level

func get_experience() -> int: return runtime.experience
	
func get_health() -> float: return runtime.get_health()

func get_max_health() -> float: return runtime.get_max_health()

func get_mana() -> float: return runtime.get_mana()

func get_max_mana() -> float: return runtime.get_max_mana()

func get_min_attack() -> int:return runtime.get_min_attack()

func get_max_attack() -> int:return runtime.get_max_attack()

func get_min_magic_attack() -> int:return runtime.get_min_()

func get_max_magic_attack() -> int:return runtime.get_max_magic_attack()

func get_min_defense() -> int:return runtime.get_min_defense()

func get_max_defense() -> int:return runtime.get_max_defense()

func get_min_magic_defense() -> int:return runtime.get_min_magic_defense()
	
func get_max_magic_defense() -> int:return runtime.get_max_magic_defense()

func get_accuracy() -> int:return runtime.get_accuracy()

func get_agility() -> int:return runtime.get_agility()

func get_luck() -> int:return runtime.get_luck()

func get_curse() -> int:return runtime.get_curse()

func get_critical_rate() -> float:return runtime.get_critical_rate()

func get_magic_dodge() -> float:return runtime.get_magic_dodge()

func get_attack_speed() -> float:return runtime.get_attack_speed()

# åºåˆ—åŒ–æ•°æ®ï¼ˆç”¨äºå­˜æ¡£ï¼‰
func serialize() -> Dictionary:
	return {
		"runtime": runtime.serialize(),
		"config": config.serialize()
	}

# ååºåˆ—åŒ–æ•°æ®
func deserialize(data: Dictionary):
	if data.has("runtime"):
		runtime.deserialize(data["runtime"])
	if data.has("config"):
		config.deserialize(data["config"])


==== res:///core/ecs/data/runtime_data.gd ====
# é«˜é¢‘å˜åŒ–çš„è¿è¡Œæ—¶æ•°æ®
class_name RuntimeData extends Resource

# çŠ¶æ€æ ‡å¿—ä½å®šä¹‰ï¼ˆä½¿ç”¨ä½è¿ç®—ï¼Œæ”¯æŒå¤šä¸ªçŠ¶æ€åŒæ—¶å­˜åœ¨ï¼‰
enum StateFlags {
	IN_BATTLE = 1,       # æˆ˜æ–—ä¸­ - å½±å“è‡ªåŠ¨å›è¡€å›è“ã€æŸäº›æŠ€èƒ½æ•ˆæœ
	POISONED = 2,        # ä¸­æ¯’ - æŒç»­æ‰£è¡€ï¼Œå½±å“ç§»åŠ¨é€Ÿåº¦
	FROZEN = 4,          # å†°å†» - æ— æ³•ç§»åŠ¨å’Œæ”»å‡»ï¼Œé˜²å¾¡åŠ›æå‡
	PARALYZED = 8,       # éº»ç—¹ - æ— æ³•ç§»åŠ¨ï¼Œå¯ä»¥æ”»å‡»ä½†å‘½ä¸­ç‡ä¸‹é™
	INVISIBLE = 16,      # éšèº« - æ€ªç‰©æ— æ³•å‘ç°ï¼Œæ”»å‡»åæ˜¾å½¢
	HIDDEN = 32,         # æ½œè¡Œ - ç§»åŠ¨é€Ÿåº¦ä¸‹é™ï¼Œæ€ªç‰©è¾ƒéš¾å‘ç°
	DEAD = 64,           # æ­»äº¡ - æ— æ³•è¿›è¡Œä»»ä½•æ“ä½œï¼Œç­‰å¾…å¤æ´»
	TRANSMITTING = 128,  # ä¼ é€ä¸­ - æ— æ•ŒçŠ¶æ€ï¼Œæ— æ³•è¢«æ”»å‡»
	SILENCED = 256,      # æ²‰é»˜ - æ— æ³•ä½¿ç”¨æŠ€èƒ½ï¼Œåªèƒ½æ™®é€šæ”»å‡»
	STUNNED = 512        # çœ©æ™• - æ— æ³•ç§»åŠ¨å’Œæ”»å‡»ï¼Œé˜²å¾¡åŠ›ä¸‹é™
}

# æˆ˜æ–—æ¨¡å¼å®šä¹‰ï¼ˆå¯ä»¥æ”¾åœ¨é¡¶éƒ¨ï¼Œä¸StateFlagså¹¶åˆ—ï¼‰
enum BattleMode {
	MANUAL = 0,      # æ‰‹åŠ¨æ¨¡å¼
	ASSIST = 1,      # ç‚¹å‡»è¾…åŠ©æ¨¡å¼  
	FULL_AUTO = 2    # å…¨è‡ªåŠ¨æ¨¡å¼
}

enum AutoBattleState {
	IDLE = 0,           # å¾…æœº
	FIND_TARGET = 1,    # å¯»æ‰¾ç›®æ ‡
	MOVE_TO_TARGET = 2, # ç§»åŠ¨åˆ°ç›®æ ‡
	ATTACKING = 3,      # æ”»å‡»ä¸­
}

# æˆ˜æ–—å±æ€§å®¹å™¨ï¼ˆç»Ÿä¸€ç±»å‹ï¼‰
var combat: CombatAttributesBase = null

# ä½ç½®å’Œç§»åŠ¨ç›¸å…³
var position: Vector2 = Vector2.ZERO
var velocity: Vector2 = Vector2.ZERO
var rotation: float = 0.0
var move_direction: Vector2 = Vector2.ZERO

var is_active: bool = true			# æ˜¯å¦æ˜¾ç¤ºã€éšè—å®ä½“
var is_moving: bool = false			# æ­»å¦ç§»åŠ¨ä¸­
var is_in_camera_view:bool = false	# æ˜¯å¦å¤„äºæ‘„åƒæœºèŒƒå›´å†…

# ç”Ÿå‘½å€¼å’ŒçŠ¶æ€
var current_health: int = 100
var current_mana: int = 50

# ç»éªŒä¸ç­‰çº§
var experience: int = 0
var level: int = 1

# çŠ¶æ€æ ‡å¿—
var state_flags: int = 0
 
# ç©å®¶æ˜¾ç¤ºåç§°
var nickname: String = ""

# æˆ˜æ–—æ¨¡å¼ç›¸å…³å­—æ®µ
var battle_mode: int = BattleMode.MANUAL

# é€šç”¨ç‚¹å‡»ç›®æ ‡ï¼ˆæ‰€æœ‰æ¨¡å¼éƒ½å¯ç”¨ï¼‰
var click_target: Dictionary = {
	"type": "none",      # "none", "move", "attack"
	"position": Vector2.INF,
	"entity_id": ""
}

# è‡ªåŠ¨æ¨¡å¼ä¸“ç”¨æ•°æ®ï¼ˆåªåœ¨ASSIST/FULL_AUTOæ—¶æœ‰æ•ˆï¼‰
var auto_data: Dictionary = {
	"state": AutoBattleState.IDLE,  # AutoBattleState
	"search_timer": 0.0,
	"target_refresh_timer": 0.0,
	"current_target_id": "",
	"last_target_position": Vector2.ZERO
}

# å½“å‰å®æ—¶æˆ˜æ–—çŠ¶æ€
var current_target_id: String = ""

func _init(initial_position: Vector2 = Vector2.ZERO):
	position = initial_position
	
# ä¼¤å®³å’Œæ²»ç–—
func take_damage(damage: int):
	current_health -= damage
	current_health = max(0, current_health)
	if current_health == 0:
		set_state_flag(StateFlags.DEAD)

func heal(amount: int):
	current_health += amount
	current_health = min(current_health, get_max_health())
	if current_health > 0 and has_state_flag(StateFlags.DEAD):
		clear_state_flag(StateFlags.DEAD)
		
# çŠ¶æ€æ£€æŸ¥
func is_alive() -> bool:
	return current_health > 0 and not has_state_flag(StateFlags.DEAD)
	
# çŠ¶æ€æ ‡å¿—æ–¹æ³•
func set_state_flag(flag: int):
	state_flags |= flag

func clear_state_flag(flag: int):
	state_flags &= ~flag

func has_state_flag(flag: int) -> bool:
	return (state_flags & flag) != 0

func get_active_states() -> Array:
	var states = []
	for flag in StateFlags.values():
		if has_state_flag(flag):
			states.append(StateFlags.keys()[StateFlags.values().find(flag)])
	return states

# åŸºç¡€å±æ€§è®¿é—®
func get_health() -> int:
	return current_health

func get_max_health() -> int:
	if combat:
		if combat.get_health() <= 0:
			return 100
		else :
			return combat.get_health()
	else :
		return 100
	
func get_mana() -> int:
	return current_mana

func get_max_mana() -> int:
	if combat:
		if combat.get_mana() <= 0:
			return 50
		else :
			return combat.get_mana()
	else :
		return 50
	
func get_min_attack() -> int:
	return combat.get_min_attack() if combat else 0

func get_max_attack() -> int:
	return combat.get_max_attack() if combat else 0

func get_min_magic_attack() -> int:
	return combat.get_min_magic_attack() if combat else 0

func get_max_magic_attack() -> int:
	return combat.get_max_magic_attack() if combat else 0
	
func get_min_defense() -> int:
	return combat.get_min_defense() if combat else 0

func get_max_defense() -> int:
	return combat.get_max_defense() if combat else 0

func get_min_magic_defense() -> int:
	return combat.get_min_magic_defense() if combat else 0
	
func get_max_magic_defense() -> int:
	return combat.get_max_magic_defense() if combat else 0

func get_accuracy() -> int:
	return combat.get_accuracy() if combat else 0

func get_agility() -> int:
	return combat.get_agility() if combat else 0

func get_luck() -> int:
	return combat.get_luck() if combat else 0

func get_curse() -> int:
	return combat.get_curse() if combat else 0

func get_magic_dodge() -> float:
	return combat.get_magic_dodge() if combat else 0.0

func get_critical_rate() -> float:
	return combat.get_critical_rate() if combat else 0.0

func get_attack_speed() -> float:
	return combat.get_attack_speed() if combat else 0.0
	
# åºåˆ—åŒ–
func serialize() -> Dictionary:
	var data = {
		"position": {"x": position.x, "y": position.y},
		"current_health": current_health,
		"current_mana": current_mana,
		"experience": experience,
		"level": level,
		"state_flags": state_flags,
		"nickname": nickname
	}
	
	# åºåˆ—åŒ–æˆ˜æ–—å±æ€§
	if combat:
		data["combat_type"] = combat.get_class_name()  # å­˜å‚¨å…·ä½“ç±»å‹
		data["combat"] = combat.serialize()
	
	return data

# ååºåˆ—åŒ–
func deserialize(data: Dictionary):
	position = Vector2(data.get("position", {}).get("x", 0), data.get("position", {}).get("y", 0))
	current_health = data.get("current_health", 0)
	current_mana = data.get("current_mana", 0)
	experience = data.get("experience", 0)
	level = data.get("level", 1)
	state_flags = data.get("state_flags", 0)
	nickname = data.get("nickname", "")
	
	# ååºåˆ—åŒ–æˆ˜æ–—å±æ€§
	var combat_type = data.get("combat_type", "")
	var combat_data = data.get("combat", {})
	
	match combat_type:
		"MonsterCombatAttributes":
			combat = MonsterCombatAttributes.new()
		"PlayerCombatAttributes":
			combat = PlayerCombatAttributes.new()
	
	if combat:
		combat.deserialize(combat_data)


==== res:///core/ecs/entities/entity_factory.gd ====
# res://core/ecs/entities/entity_factory.gd
class_name EntityFactory

# åˆ›å»ºæ€ªç‰©å®ä½“
static func create_monster(monster_id: String, position: Vector2 = Vector2.ZERO, parent_node: Node = null) -> GameEntity:
	# éªŒè¯æ€ªç‰©é…ç½®æ˜¯å¦å­˜åœ¨
	if not Game.config_manager.monster_templates.has(monster_id):
		push_error("æ€ªç‰©é…ç½®ä¸å­˜åœ¨: " + monster_id)
		return null
	
	# è·å–æ€ªç‰©é…ç½®æ•°æ®
	var monster_data = Game.config_manager.monster_templates[monster_id]
	var monster_skills = monster_data.get("skills", [])
	
	# ç”Ÿæˆå”¯ä¸€å®ä½“ID
	var entity_id = "monster_%s_%s" % [monster_id, _generate_unique_id()]
	
	# åˆ›å»ºConfigData - åªè®¾ç½®æœ€åŸºç¡€çš„èº«ä»½ä¿¡æ¯
	var config = ConfigData.new(
		entity_id,
		monster_data.monster_name,
		"monster",
		"monster"
	)
	config.ai_behavior = monster_data.get("ai_behavior", "passive")
	config.monster_rank = monster_data.get("monster_rank", "normal")
	for skill_id in monster_skills:
		# æ€ªç‰©æŠ€èƒ½ä¸éœ€è¦å­˜åˆ°player_skillsï¼Œç›´æ¥åœ¨ConfigDataä¸­è®¾ç½®
		if not config.skills.has(skill_id):
			config.skills.append(skill_id)
	
	# åˆ›å»ºRuntimeData - ä½¿ç”¨MonsterCombatAttributes
	var runtime := RuntimeData.new(position)
	runtime.combat = MonsterCombatAttributes.new()
	
	# è®¾ç½®æ€ªç‰©åŸºç¡€å±æ€§ï¼ˆbaseå±‚ï¼‰
	runtime.combat.base.deserialize(monster_data)
	
	# åˆå§‹åŒ–å½“å‰å€¼
	runtime.current_health = runtime.combat.get_health()
	runtime.current_mana = runtime.combat.get_mana()
	runtime.level = monster_data.level
	
	# åˆ›å»ºEntityData
	var entity_data = EntityData.new(runtime, config)
	
	# åˆ›å»ºGameEntity
	var game_entity = GameEntity.new()
	game_entity.setup(entity_data)
	
	# æŒ‚è½½åˆ°çˆ¶èŠ‚ç‚¹
	if parent_node and parent_node is Node:
		parent_node.add_child(game_entity)
		print("âœ… æ€ªç‰©æŒ‚è½½å®Œæˆ: ", monster_data.monster_name)
	else:
		push_warning("âš ï¸ æ€ªç‰©åˆ›å»ºä½†æœªæŒ‚è½½: " + monster_data.monster_name)
	
	# è‡ªåŠ¨æ³¨å†Œåˆ°ECSç³»ç»Ÿ
	EntityRegistry.register_entity(game_entity)
	
	print("âœ… æ€ªç‰©åˆ›å»ºæˆåŠŸ: %s (%s) ä½ç½®: %s" % [monster_data.monster_name, monster_id, position])
	return game_entity

# åˆ›å»ºç©å®¶å®ä½“
static func create_player_from_profile(position: Vector2 = Vector2.ZERO, parent_node: Node = null) -> GameEntity:
	var profile = Game.data.profile
	
	# æ ¹æ®èŒä¸šé€‰æ‹©ç©å®¶é…ç½®ID
	var config_id = _get_player_config_id(profile.job)
	
	# ç”Ÿæˆå”¯ä¸€å®ä½“ID
	var entity_id = "player_%d_%s" % [profile.user_id, _generate_unique_id()]
	
	# åˆ›å»ºConfigData - åªè®¾ç½®æœ€åŸºç¡€çš„èº«ä»½ä¿¡æ¯
	var config = ConfigData.new(
		entity_id,
		"",  # åç§°ç•™ç©ºï¼Œä½¿ç”¨æ˜µç§°
		"player",
		_get_class_string(profile.job)
	)
	
	# åˆ›å»ºRuntimeData - ä½¿ç”¨PlayerCombatAttributes
	var runtime = RuntimeData.new(position)
	runtime.combat = PlayerCombatAttributes.new()
	
	# è®¾ç½®ç©å®¶ä¸ªæ€§åŒ–æ•°æ®
	runtime.nickname = profile.nickname
	runtime.level = profile.level
	runtime.experience = profile.experience
	
	# ä»èŒä¸šæ¨¡æ¿åˆå§‹åŒ–åŸºç¡€å±æ€§
	var job_template = Game.config_manager.player_templates.get(config_id, {})
	runtime.combat.job.deserialize(job_template)
	
	# åˆå§‹åŒ–å½“å‰å€¼
	runtime.current_health = runtime.get_health()
	runtime.current_mana = runtime.get_mana()
	
	# è®¾ç½®ç©æ³•çŠ¶æ€
	var session = Game.data.gameplay_session_data
	#runtime.auto_battle = session.auto_battle
	#runtime.current_battle_mode = session.current_battle_mode
	
	# ğŸ¯ åˆå§‹åŒ–ç©å®¶æŠ€èƒ½
	_initialize_player_skills(profile, config)
	
	# åˆ›å»ºEntityData
	var entity_data = EntityData.new(runtime, config)
	
	# åˆ›å»ºGameEntity
	var game_entity = GameEntity.new()
	game_entity.setup(entity_data)
	
	# æŒ‚è½½åˆ°çˆ¶èŠ‚ç‚¹
	if parent_node and parent_node is Node:
		parent_node.add_child(game_entity)
		print("âœ… ç©å®¶æŒ‚è½½å®Œæˆ: ", profile.nickname)
	else:
		push_warning("âš ï¸ ç©å®¶åˆ›å»ºä½†æœªæŒ‚è½½: " + profile.nickname)
	
	# è‡ªåŠ¨æ³¨å†Œåˆ°ECSç³»ç»Ÿ
	EntityRegistry.register_entity(game_entity)
	
	print("âœ… ç©å®¶åˆ›å»ºæˆåŠŸ: %s Lv.%d ä½ç½®: %s" % [profile.nickname, profile.level, position])
	return game_entity

# åˆ›å»ºNPCå®ä½“
static func create_npc(npc_id: String, position: Vector2 = Vector2.ZERO, parent_node: Node = null) -> GameEntity:
	# è¿™é‡Œéœ€è¦ä½ æœ‰npc_templatesé…ç½®
	if not Game.config_manager.has("npc_templates") or not Game.config_manager.npc_templates.has(npc_id):
		push_error("NPCé…ç½®ä¸å­˜åœ¨: " + npc_id)
		return null
	
	var npc_data = Game.config_manager.npc_templates[npc_id]
	
	# ç”Ÿæˆå”¯ä¸€å®ä½“ID
	var entity_id = "npc_%s_%s" % [npc_id, _generate_unique_id()]
	
	# åˆ›å»ºConfigData
	var config = ConfigData.new(
		entity_id,
		npc_data.npc_name,
		"npc",
		"npc"
	)
	
	# åˆ›å»ºRuntimeData - NPCå¯èƒ½ä¸éœ€è¦æˆ˜æ–—å±æ€§ï¼Œæˆ–è€…ä½¿ç”¨åŸºç¡€ç‰ˆæœ¬
	var runtime = RuntimeData.new(position)
	# runtime.combat = NPCCombatAttributes.new()  # å¦‚æœéœ€è¦çš„è¯
	
	# åˆ›å»ºEntityData
	var entity_data = EntityData.new(runtime, config)
	
	# åˆ›å»ºGameEntity
	var game_entity = GameEntity.new()
	game_entity.setup(entity_data)
	
	# æŒ‚è½½åˆ°çˆ¶èŠ‚ç‚¹
	if parent_node and parent_node is Node:
		parent_node.add_child(game_entity)
		print("âœ… NPCæŒ‚è½½å®Œæˆ: ", npc_data.npc_name)
	
	# è‡ªåŠ¨æ³¨å†Œåˆ°ECSç³»ç»Ÿ
	EntityRegistry.register_entity(game_entity)
	
	print("âœ… NPCåˆ›å»ºæˆåŠŸ: %s (%s) ä½ç½®: %s" % [npc_data.npc_name, npc_id, position])
	return game_entity

static func _initialize_player_skills(profile: UserProfileData, config: ConfigData):
	# 2. æ¸…ç©ºConfigDataä¸­çš„æŠ€èƒ½åˆ—è¡¨ï¼ˆå‡†å¤‡é‡æ–°æ„å»ºï¼‰
	config.skills.clear()
	
	# 5. æ·»åŠ é¢å¤–å­¦ä¹ çš„æŠ€èƒ½ï¼ˆä¸åœ¨èŒä¸šåŸºç¡€ä¸­çš„ï¼‰
	for skill_id in Game.data.player_skills.skills:
		if not config.skills.has(skill_id):
			config.skills.append(skill_id)
	
	print("âœ… ç©å®¶æŠ€èƒ½åˆå§‹åŒ–: %s - èŒä¸š: %s, æŠ€èƒ½æ•°: %d" % [
		profile.nickname, 
		_get_class_string(profile.job),
		config.skills.size()
	])

	
# ğŸ› ï¸ å·¥å…·æ–¹æ³•

# è·å–æ‰€æœ‰å¯ç”¨çš„æ€ªç‰©ID
static func get_available_monsters() -> Array[String]:
	return Game.config_manager.monster_templates.keys()

# æ£€æŸ¥æ€ªç‰©é…ç½®æ˜¯å¦å­˜åœ¨
static func monster_exists(monster_id: String) -> bool:
	return Game.config_manager.monster_templates.has(monster_id)

# è·å–æ‰€æœ‰å¯ç”¨çš„ç©å®¶èŒä¸šé…ç½®ID
static func get_available_player_classes() -> Array[String]:
	if Game.config_manager.has("player_templates"):
		return Game.config_manager.player_templates.keys()
	return ["player_warrior", "player_mage", "player_taoist"]

# ğŸ¯ å†…éƒ¨å·¥å…·æ–¹æ³•

static func _generate_unique_id() -> String:
	return str(Time.get_ticks_msec()) + "_" + str(randi() % 10000)

static func _get_player_config_id(job: int) -> String:
	match job:
		1: return "player_warrior"
		2: return "player_mage" 
		3: return "player_taoist"
		_: return "player_warrior"

static func _get_class_string(job: int) -> String:
	match job:
		1: return "warrior"
		2: return "mage"
		3: return "taoist"
		_: return "warrior"


==== res:///core/ecs/entities/game_entity.gd ====
# game_entity.gd
extends CharacterBody2D
class_name GameEntity

## å…±äº«çš„ CircleShape2D èµ„æº
var data: EntityData
var collision_shape: CollisionShape2D

# åˆå§‹åŒ–å‡½æ•°
func setup(entity_data: EntityData) -> void:
	#"""åˆå§‹åŒ–å®ä½“ï¼Œç»‘å®šæ•°æ®å¹¶è¿æ¥ä¿¡å·"""
	data = entity_data
	
	# è¿æ¥åŸºç¡€è¡¨ç°ç›¸å…³çš„ä¿¡å·
	_connect_signals()
	
	_initial_sync()
	print("GameEntity åˆå§‹åŒ–å®Œæˆ: ", data.config.entity_name)

# åˆå§‹åŒæ­¥ï¼šç”¨å½“å‰æ•°æ®åˆå§‹åŒ–åŸºç¡€è¡¨ç°
func _initial_sync() -> void:
   # """å°†åˆå§‹æ•°æ®åŒæ­¥åˆ°èŠ‚ç‚¹è¡¨ç°"""
	position = data.get_position()
	visible = data.runtime.is_active
	
	# åˆ›å»ºç¢°æ’ç›’
	_create_collision_shape()
	
	print("å®ä½“åˆå§‹åŒ–: %s ä½ç½®: %s" % [data.config.entity_name, position])
	
# è¿æ¥æ•°æ®å˜åŒ–çš„ä¿¡å·
func _connect_signals() -> void:
	 # ä½ç½®å˜åŒ–åŒæ­¥
	data.position_changed.connect(_on_position_changed)
	# ç”Ÿå‘½å€¼å˜åŒ–åŒæ­¥
	data.health_changed.connect(_on_health_changed)
	# é€šç”¨æ•°æ®å˜åŒ–
	data.data_changed.connect(_on_data_changed)
	
func _on_position_changed(old_pos: Vector2, new_pos: Vector2):
	position = new_pos
	print("å®ä½“ %s ä½ç½®æ›´æ–°: %s -> %s" % [data.config.entity_name, old_pos, new_pos])

func _on_health_changed(old_health: int, new_health: int):
	print("å®ä½“ %s ç”Ÿå‘½å€¼å˜åŒ–: %d -> %d" % [data.config.entity_name, old_health, new_health])
	# è¿™é‡Œå¯ä»¥æ·»åŠ è¡€æ¡æ›´æ–°ã€å—ä¼¤åŠ¨ç”»ç­‰

func _on_data_changed(property_name: String, old_value, new_value):
	print("å®ä½“ %s æ•°æ®å˜åŒ–: %s = %s -> %s" % [
		data.config.entity_name, property_name, old_value, new_value
	])
	

func get_entity_data() -> EntityData:
	#"""è·å–å®ä½“æ•°æ®ï¼ˆä¾›Systemä½¿ç”¨ï¼‰"""
	return data
	
# ç»Ÿä¸€ç§»åŠ¨æ¥å£ï¼Œå­ç±»ç›´æ¥è°ƒ
func move() -> void:
	move_and_slide()

# åˆ›å»ºç¢°æ’ç›’
func _create_collision_shape() -> void:
	collision_shape = CollisionShape2D.new()
	collision_shape.shape = Game.SHARED_CIRCLE_44
	add_child(collision_shape)
	
	# 1-terrain 2-entity 3-bullet 4-trigger
	var layer := 0
	var mask  := 0
	match data.config.entity_type:
		"player":
			layer = 1<<1          # åªåœ¨ç¬¬ 2 å±‚ï¼ˆentityï¼‰
			mask  = (1<<0) | (1<<1) | (1<<3)   # æ’ terrain+entity+trigger
		"monster":
			layer = 1<<1
			mask  = (1<<0) | (1<<1) | (1<<2)   # æ’ terrain+entity+bullet
		"npc":
			layer = 1<<1
			mask  = 1<<0                       # åªæ’ terrain
		"item":
			layer = 1<<3                       # æ”¾åœ¨ trigger å±‚
			mask  = 0                          # ä¸ä¸»åŠ¨æ’ä»»ä½•å±‚

	set_collision_layer(layer)
	set_collision_mask(mask)
	
func is_entity_active() -> bool:
	return data != null and data.runtime.is_alive()


==== res:///core/ecs/systems/infrastructure/camera_system.gd ====
class_name CameraSystem extends SystemBase

# ç›¸æœºé…ç½®
var _camera: Camera2D
var _target_entity: GameEntity
var _smoothing_speed: float = 5.0

# ğŸ¯ åŠ¨æ€è·å–åˆ†è¾¨ç‡
var _viewport_size: Vector2 = Vector2.ZERO
var _base_zoom: float = 2.2
var _viewport_scale: float = 1.0  # è§†å£ç¼©æ”¾æ¯”ä¾‹
var _design_resolution: Vector2 = Vector2(1080, 2340)  # è®¾è®¡åˆ†è¾¨ç‡ï¼ˆç«–å±ï¼‰

# ğŸ¯ ç›¸æœºåç§»é…ç½®ï¼ˆè®©ç©å®¶åœ¨å±å¹•ä¸­å¤®åä¸‹ï¼‰
var _vertical_offset_ratio: float = 0.15  # å‘ä¸‹åç§»å±å¹•é«˜åº¦çš„15%
var _vertical_offset: float = 0.0  # è®¡ç®—åçš„å®é™…åç§»é‡

# ç¼“å­˜ç›¸æœºçŸ©å½¢ï¼Œé¿å…æ¯å¸§é‡å¤è®¡ç®—
var _cached_camera_rect: Rect2 = Rect2()
var _camera_rect_dirty: bool = true

func _initialize():
	system_name = "CameraSystem"
	system_type = "infrastructure"
	
	# å¯ç”¨æ‰¹å¤„ç†ä¼˜åŒ–
	use_batch_processing = true
	batch_size = 20
	batch_threshold = 30
	
	# åˆå§‹åŒ–è§†å£å¤§å°
	_update_viewport_size()

# ğŸ¯ åŠ¨æ€æ›´æ–°è§†å£å¤§å°
func _update_viewport_size():
	var viewport = get_viewport()
	if viewport:
		_viewport_size = viewport.size
		
		# ğŸ¯ è®¡ç®—ç›¸å¯¹äºè®¾è®¡åˆ†è¾¨ç‡çš„ç¼©æ”¾æ¯”ä¾‹
		# ä¿æŒå®½é«˜æ¯”ï¼Œä»¥è¾ƒçŸ­è¾¹ä¸ºåŸºå‡†
		var scale_x = _viewport_size.x / _design_resolution.x
		var scale_y = _viewport_size.y / _design_resolution.y
		_viewport_scale = min(scale_x, scale_y)
		
		# é™åˆ¶ç¼©æ”¾èŒƒå›´
		_viewport_scale = clamp(_viewport_scale, 0.5, 2.0)
		
		# ğŸ¯ è®¡ç®—å®é™…å‚ç›´åç§»ï¼ˆåƒç´ ï¼‰
		_vertical_offset = _viewport_size.y * _vertical_offset_ratio
		
		print("ğŸ“ è§†å£æ›´æ–°: ", _viewport_size, " ç¼©æ”¾: ", _viewport_scale, " åç§»: ", _vertical_offset)
		_camera_rect_dirty = true  # æ ‡è®°ç›¸æœºçŸ©å½¢éœ€è¦é‡æ–°è®¡ç®—
	else:
		# å›é€€åˆ°è®¾è®¡åˆ†è¾¨ç‡
		_viewport_size = _design_resolution
		_viewport_scale = 1.0
		_vertical_offset = _design_resolution.y * _vertical_offset_ratio
		_camera_rect_dirty = true

func _should_process_entity(entity: GameEntity) -> bool:
	# ğŸ¯ ä½ çš„åˆ¤æ–­æ¡ä»¶æ˜¯å¯¹çš„ï¼š
	# 1. å®ä½“å­˜åœ¨
	# 2. å®ä½“æ¿€æ´»çŠ¶æ€
	# 3. å®ä½“æ´»ç€ï¼ˆå¦‚æœæœ‰ç”Ÿå‘½å€¼æ¦‚å¿µï¼‰
	return entity != null and entity.is_entity_active()

# ğŸ¯ å¤„ç†å•ä¸ªå®ä½“ï¼šæ›´æ–°å…¶è§†é”¥çŠ¶æ€
func _process_entity(entity: GameEntity, _delta: float):
	if not entity or not entity.data:
		return
	
	# æ›´æ–°ç›¸æœºçŸ©å½¢ç¼“å­˜
	if _camera_rect_dirty:
		_cached_camera_rect = _get_camera_rect()
		_camera_rect_dirty = false
	
	# åˆ¤æ–­å®ä½“æ˜¯å¦åœ¨ç›¸æœºè§†é”¥å†…
	var is_in_view = _is_point_in_camera_view(entity.global_position, _cached_camera_rect)
	
	# è®¾ç½®è§†é”¥æ ‡å¿—
	entity.data.runtime.is_in_camera_view = is_in_view

func _on_entity_registered(entity: GameEntity):
	var entity_type = entity.data.config.entity_type
	
	if entity_type == "player":
		print("ğŸ“· æ£€æµ‹åˆ°ç©å®¶æ³¨å†Œ: ", entity.data.config.entity_name)
		_target_entity = entity
		_ensure_camera_exists()
		snap_to_target()
		print("âœ… ç›¸æœºå¼€å§‹è·Ÿéšç©å®¶")
	
	# æ³¨å†Œå®ä½“åˆ°ç³»ç»Ÿï¼ˆè®©çˆ¶ç±»ç®¡ç†ï¼‰
	super.register_entity(entity)

func _on_entity_unregistered(entity: GameEntity):
	if entity == _target_entity:
		print("ğŸ“· ç›®æ ‡å®ä½“æ³¨é”€ï¼Œåœæ­¢è·Ÿéš: ", entity.data.config.entity_name)
		_target_entity = null
	
	# ä»ç³»ç»Ÿæ³¨é”€å®ä½“
	super.unregister_entity(entity)

func _ensure_camera_exists():
	if not _camera or not is_instance_valid(_camera):
		_create_camera()
	else:
		if not _camera.is_current():
			_camera.make_current()

func _create_camera():
	if _camera and is_instance_valid(_camera):
		_camera.queue_free()
	
	_camera = Camera2D.new()
	_camera.name = "MainCamera"
	
	# ğŸ¯ åŠ¨æ€è®¡ç®—ç¼©æ”¾
	# åŸºç¡€ç¼©æ”¾ * (1/è§†å£ç¼©æ”¾) ä¿æŒå†…å®¹å¤§å°ä¸€è‡´
	var dynamic_zoom = _base_zoom * (1.0 / _viewport_scale)
	_camera.zoom = Vector2(dynamic_zoom, dynamic_zoom)
	
	_camera.position_smoothing_enabled = true
	_camera.position_smoothing_speed = _smoothing_speed
	_camera.ignore_rotation = true
	_camera.anchor_mode = Camera2D.ANCHOR_MODE_DRAG_CENTER  # å±…ä¸­é”šç‚¹
	
	# ğŸ¯ ç§»é™¤è¾¹ç•Œé™åˆ¶
	_camera.limit_left = -100000
	_camera.limit_top = -100000
	_camera.limit_right = 100000
	_camera.limit_bottom = 100000
	
	var scene_root = get_tree().current_scene
	if scene_root:
		scene_root.add_child(_camera)
		_camera.make_current()
		
		print("ğŸ“· è‡ªé€‚åº”ç›¸æœºåˆ›å»ºå®Œæˆ")
		print("   åŠ¨æ€ç¼©æ”¾: ", dynamic_zoom)
		print("   é”šç‚¹æ¨¡å¼: ", _camera.anchor_mode)
		
		_camera_rect_dirty = true  # ç›¸æœºåˆ›å»ºåéœ€è¦æ›´æ–°çŸ©å½¢

# ğŸ¯ ç«‹å³è·³è½¬åˆ°ç›®æ ‡ä½ç½®ï¼ˆå¸¦å‚ç›´åç§»ï¼‰
func snap_to_target():
	if not _target_entity or not _camera or not is_instance_valid(_target_entity):
		return
	
	var target_pos = _target_entity.global_position
	
	# ğŸ¯ å…³é”®ï¼šåº”ç”¨å‚ç›´åç§»
	# ç©å®¶ä½ç½®å‘ä¸Šç§»åŠ¨ï¼Œè®©ç©å®¶åœ¨å±å¹•ä¸­åä¸‹
	var camera_target_pos = target_pos
	camera_target_pos.y -= _vertical_offset / _camera.zoom.y  # éœ€è¦è€ƒè™‘ç›¸æœºç¼©æ”¾
	
	_camera.global_position = camera_target_pos
	
	# æ ‡è®°ç›¸æœºçŸ©å½¢éœ€è¦æ›´æ–°
	_camera_rect_dirty = true
	
	print("ğŸ¯ ç›¸æœºå®šä½è°ƒè¯•:")
	print("   ç©å®¶ä½ç½®: ", target_pos)
	print("   å‚ç›´åç§»: ", _vertical_offset, "åƒç´ ")
	print("   è€ƒè™‘ç¼©æ”¾åçš„åç§»: ", _vertical_offset / _camera.zoom.y)
	print("   ç›¸æœºç›®æ ‡ä½ç½®: ", camera_target_pos)

# ğŸ¯ ç³»ç»Ÿæ›´æ–°ï¼šå¹³æ»‘è·Ÿéšç›®æ ‡ï¼ˆå¸¦å‚ç›´åç§»ï¼‰
func process_system(delta: float):
	if not enabled:
		return
	
	# 1. ç›¸æœºè·Ÿéšç›®æ ‡
	_follow_target(delta)
	
	# 2. ğŸ¯ ä½¿ç”¨çˆ¶ç±»çš„åˆ†å¸§å¤„ç†æœºåˆ¶æ›´æ–°å®ä½“è§†é”¥çŠ¶æ€
	super.process_system(delta)

func _follow_target(delta: float):
	if not _target_entity or not _camera:
		return
	
	if not is_instance_valid(_target_entity):
		_target_entity = null
		return
	
	var target_pos = _target_entity.global_position
	
	# ğŸ¯ åº”ç”¨å‚ç›´åç§»
	var camera_target_pos = target_pos
	camera_target_pos.y -= _vertical_offset / _camera.zoom.y
	
	# å¹³æ»‘æ’å€¼
	var current_pos = _camera.global_position
	var new_pos = current_pos.lerp(camera_target_pos, delta * _smoothing_speed)
	
	# åªæœ‰ä½ç½®å˜åŒ–æ—¶æ‰æ›´æ–°
	if new_pos != current_pos:
		_camera.global_position = new_pos
		_camera_rect_dirty = true  # ä½ç½®å˜åŒ–éœ€è¦æ›´æ–°ç›¸æœºçŸ©å½¢

# ğŸ¯ è·å–ç›¸æœºå®é™…è¦†ç›–çš„çŸ©å½¢åŒºåŸŸï¼ˆè€ƒè™‘å‚ç›´åç§»ï¼‰
func _get_camera_rect() -> Rect2:
	if not _camera:
		return Rect2()
	
	var camera_pos = _camera.global_position
	var scaled_viewport = _viewport_size / _camera.zoom
	
	# ğŸ¯ å¯¹äºå±…ä¸­é”šç‚¹ï¼Œè€ƒè™‘å‚ç›´åç§»
	# å®é™…ç›¸æœºçŸ©å½¢åº”è¯¥å‘ä¸Šåç§»ï¼Œå› ä¸ºç›¸æœºä½ç½®å·²ç»å‘ä¸‹è°ƒæ•´äº†
	var actual_camera_pos = camera_pos
	actual_camera_pos.y += _vertical_offset / _camera.zoom.y  # åå‘è¡¥å¿åç§»
	
	return Rect2(actual_camera_pos - scaled_viewport * 0.5, scaled_viewport)

# ğŸ¯ åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ç›¸æœºè§†é”¥å†…
func _is_point_in_camera_view(point: Vector2, camera_rect: Rect2) -> bool:
	# æ‰©å±•åˆ¤å®šåŒºåŸŸï¼ˆç»™ç‰©ç†ç³»ç»Ÿä¸€äº›ç¼“å†²ï¼‰
	var extended_rect = camera_rect.grow(200.0)  # 200åƒç´ ç¼“å†²
	return extended_rect.has_point(point)

# ğŸ¯ è®¾ç½®å‚ç›´åç§»æ¯”ä¾‹
func set_vertical_offset_ratio(ratio: float):
	_vertical_offset_ratio = clamp(ratio, 0.0, 0.4)  # é™åˆ¶åœ¨0-40%ä¹‹é—´
	_vertical_offset = _viewport_size.y * _vertical_offset_ratio
	_camera_rect_dirty = true  # åç§»å˜åŒ–éœ€è¦æ›´æ–°ç›¸æœºçŸ©å½¢
	print("ğŸ“ å‚ç›´åç§»æ¯”ä¾‹è®¾ç½®ä¸º: ", _vertical_offset_ratio, " (", _vertical_offset, "åƒç´ )")

# ğŸ¯ è®¾ç½®ç›¸æœºç¼©æ”¾
func set_zoom(zoom_level: float):
	if _camera:
		_camera.zoom = Vector2(zoom_level, zoom_level)
		_camera_rect_dirty = true  # ç¼©æ”¾å˜åŒ–éœ€è¦æ›´æ–°ç›¸æœºçŸ©å½¢
		print("ğŸ” ç›¸æœºç¼©æ”¾è®¾ç½®ä¸º: ", zoom_level)

# ğŸ¯ è·å–å½“å‰ç›¸æœºä¿¡æ¯
func get_camera_info() -> Dictionary:
	if not _camera:
		return {}
	
	var target_pos = _target_entity.global_position if _target_entity and is_instance_valid(_target_entity) else Vector2.ZERO
	var scaled_viewport = _viewport_size / _camera.zoom
	
	# ç¡®ä¿ç›¸æœºçŸ©å½¢æ˜¯æœ€æ–°çš„
	if _camera_rect_dirty:
		_cached_camera_rect = _get_camera_rect()
		_camera_rect_dirty = false
	
	return {
		"position": _camera.global_position,
		"zoom": _camera.zoom,
		"target": _target_entity.data.config.entity_name if _target_entity and is_instance_valid(_target_entity) else "æ— ",
		"target_position": target_pos,
		"viewport_size": _viewport_size,
		"scaled_viewport": scaled_viewport,
		"design_resolution": _design_resolution,
		"viewport_scale": _viewport_scale,
		"vertical_offset": _vertical_offset,
		"vertical_offset_ratio": _vertical_offset_ratio,
		"camera_rect": _cached_camera_rect,
		"entities_in_system": entities.size(),
		"is_active": _camera.is_current()
	}

func force_update():
	if _target_entity and _camera:
		snap_to_target()
		_camera_rect_dirty = true
		print("ğŸ”„ å¼ºåˆ¶æ›´æ–°ç›¸æœºä½ç½®")

func get_system_info() -> Dictionary:
	var info = super.get_system_info()
	var camera_info = get_camera_info()
	info["camera"] = camera_info
	return info


==== res:///core/ecs/systems/render/health_bar_system.gd ====
# res://core/ecs/systems/render/health_bar_system.gd
class_name HealthBarSystem
extends SystemBase

# è¡€æ¡æ•°æ®ç±»
class HealthBarData:
	var entity: GameEntity
	var world_position: Vector2
	var health_ratio: float
	var is_visible: bool
	var entity_type: String
	
	func _init(entity_ref: GameEntity):
		entity = entity_ref
		update_data()
	
	func update_data():
		if is_instance_valid(entity) and entity.data:
			world_position = entity.data.get_position()
			health_ratio = entity.data.get_health() / entity.data.get_max_health()
			is_visible = entity.data.is_alive() and entity.data.runtime.is_active
			entity_type = entity.data.config.entity_type

var _health_bars: Array[HealthBarData] = []

func _initialize():
	system_name = "HealthBarSystem"
	system_type = "render"
	#update_priority = 95  # åœ¨ç²¾çµä¹‹åï¼ŒUIä¹‹å‰
	
	# ğŸ¯ ä¿®å¤ï¼šä½¿ç”¨Y Sortè€Œä¸æ˜¯CanvasLayer
	z_index = 90  # è®¾ç½®è¾ƒé«˜çš„Z Index
	z_as_relative = false
	
	print("HealthBarSystem åˆå§‹åŒ–å®Œæˆ")

# åªå¤„ç†éœ€è¦è¡€æ¡çš„å®ä½“
func _should_process_entity(entity: GameEntity) -> bool:
	return entity.data.config.entity_type in ["player", "monster", "boss"]

func _process_entity(_entity: GameEntity, _delta: float):
	# è¿™ä¸ªç³»ç»Ÿä¸æŒ‰å®ä½“å¤„ç†ï¼Œè€Œæ˜¯æ‰¹é‡ç»˜åˆ¶
	pass

func _on_entity_registered(entity: GameEntity):
	if _should_process_entity(entity):
		var health_bar = HealthBarData.new(entity)
		_health_bars.append(health_bar)
		print("âœ… è¡€æ¡ç³»ç»Ÿæ³¨å†Œå®ä½“: ", entity.data.get_display_name())

func _on_entity_unregistered(entity: GameEntity):
	for i in range(_health_bars.size() - 1, -1, -1):
		if _health_bars[i].entity == entity:
			_health_bars.remove_at(i)
			print("ğŸ—‘ï¸ è¡€æ¡ç³»ç»Ÿç§»é™¤å®ä½“: ", entity.data.get_display_name())
			break

# æ¯å¸§æ›´æ–°è¡€æ¡æ•°æ®å¹¶é‡ç»˜
func process_system(_delta: float):
	if not enabled:
		return
	
	# æ›´æ–°æ‰€æœ‰è¡€æ¡æ•°æ®
	for health_bar in _health_bars:
		health_bar.update_data()
	
	# è¯·æ±‚é‡ç»˜
	queue_redraw()

# æ‰¹é‡ç»˜åˆ¶æ‰€æœ‰è¡€æ¡
func _draw():
	for health_bar in _health_bars:
		if health_bar.is_visible:
			_draw_single_health_bar(health_bar)

func _draw_single_health_bar(health_bar: HealthBarData):
	var screen_pos = health_bar.world_position
		
	# è¡€æ¡åœ¨å¤´é¡¶åç§»
	var y_offset = -50
	if health_bar.entity_type == "player":
		y_offset = -60
	elif health_bar.entity_type == "monster":
		y_offset = -40
	
	screen_pos.y += y_offset
	
	# è¡€æ¡å°ºå¯¸
	var width = 50
	var height = 6
	var border = 1
	
	# èƒŒæ™¯ï¼ˆé»‘è‰²è¾¹æ¡†ï¼‰
	draw_rect(Rect2(
		screen_pos.x - width/2.0 - border, 
		screen_pos.y - border, 
		width + border*2, 
		height + border*2
	), Color.BLACK)
	
	# èƒŒæ™¯ï¼ˆç°è‰²åº•ï¼‰
	draw_rect(Rect2(
		screen_pos.x - width/2.0, 
		screen_pos.y, 
		width, 
		height
	), Color.DARK_GRAY)
	
	# è¡€é‡ï¼ˆé¢œè‰²æ¸å˜ï¼‰
	var health_width = width * health_bar.health_ratio
	var health_color = _get_health_color(health_bar.health_ratio, health_bar.entity_type)
	
	if health_width > 0:
		draw_rect(Rect2(
			screen_pos.x - width/2.0, 
			screen_pos.y, 
			health_width, 
			height
		), health_color)

func _get_health_color(ratio: float, entity_type: String) -> Color:
	# ä¼ å¥‡é£æ ¼é¢œè‰²æ¸å˜
	if entity_type == "player":
		# ç©å®¶è¡€æ¡ï¼šç»¿â†’é»„â†’çº¢
		if ratio > 0.6:
			return Color.GREEN
		elif ratio > 0.3:
			return Color.YELLOW
		else:
			return Color.RED
	else:
		# æ€ªç‰©è¡€æ¡ï¼šçº¢â†’æ©™â†’é»„
		if ratio > 0.6:
			return Color.RED
		elif ratio > 0.3:
			return Color.ORANGE
		else:
			return Color.YELLOW

# è°ƒè¯•ä¿¡æ¯
func get_system_info() -> Dictionary:
	var info = super.get_system_info()
	info["health_bar_count"] = _health_bars.size()
	return info


==== res:///core/ecs/systems/render/name_label_system.gd ====
# res://core/ecs/systems/render/name_label_system.gd
class_name NameLabelSystem
extends SystemBase

# åå­—æ•°æ®ç±»
class NameLabelData:
	var entity: GameEntity
	var world_position: Vector2
	var is_visible: bool
	var entity_name: String
	var entity_type: String
	var should_show_name: bool  # ğŸ†• æ˜¯å¦åº”è¯¥æ˜¾ç¤ºåå­—
	
	func _init(entity_ref: GameEntity):
		entity = entity_ref
		update_data()
	
	func update_data():
		if is_instance_valid(entity) and entity.data:
			var runtime = entity.data.runtime
			var config = entity.data.config
			var base_name = runtime.nickname if runtime.nickname != "" else config.entity_name

			world_position = entity.data.get_position()
			is_visible = entity.data.is_alive() and entity.data.runtime.is_active
			entity_name = base_name
			entity_type = entity.data.config.entity_type
			
			# ğŸ†• åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºåå­—ï¼šBOSSå§‹ç»ˆæ˜¾ç¤ºï¼Œå…¶ä»–å®ä½“å—ä¼¤æ‰æ˜¾ç¤º
			# BOSSå’Œç©å®¶å§‹ç»ˆæ˜¾ç¤ºï¼Œå…¶ä»–å®ä½“å—ä¼¤æ‰æ˜¾ç¤º
			if entity_type == "boss" or entity_type == "player":
				should_show_name = true  # BOSSå’Œç©å®¶å§‹ç»ˆæ˜¾ç¤º
			else:
				# å…¶ä»–å®ä½“ï¼šå—ä¼¤ï¼ˆå½“å‰è¡€é‡ < æœ€å¤§è¡€é‡ï¼‰æ‰æ˜¾ç¤º
				var current_health = entity.data.get_health()
				var max_health = entity.data.get_max_health()
				should_show_name = current_health < max_health
				

var _name_labels: Array[NameLabelData] = []
var _font: Font

func _initialize():
	system_name = "NameLabelSystem"
	system_type = "render"
	#update_priority = 96
	
	# åˆ›å»ºå­—ä½“
	_font = _create_font()
	
	# ğŸ¯ ä¿®å¤ï¼šä½¿ç”¨Y Sortè€Œä¸æ˜¯CanvasLayer
	z_index = 90  # è®¾ç½®è¾ƒé«˜çš„Z Index
	z_as_relative = false
	
	print("NameLabelSystem åˆå§‹åŒ–å®Œæˆ")

func _create_font() -> Font:
	# Godot 4.x æœ€ç®€å•çš„æ–¹æ³•
	return ThemeDB.fallback_font

func _should_process_entity(entity: GameEntity) -> bool:
	return entity.data.config.entity_type in ["player", "monster", "npc", "boss"]

func _on_entity_registered(entity: GameEntity):
	if _should_process_entity(entity):
		var name_label = NameLabelData.new(entity)
		_name_labels.append(name_label)
		print("âœ… åå­—ç³»ç»Ÿæ³¨å†Œå®ä½“: ", entity.data.get_display_name())

func _on_entity_unregistered(entity: GameEntity):
	for i in range(_name_labels.size() - 1, -1, -1):
		if _name_labels[i].entity == entity:
			_name_labels.remove_at(i)
			print("ğŸ—‘ï¸ åå­—ç³»ç»Ÿç§»é™¤å®ä½“: ", entity.data.get_display_name())
			break

func process_system(_delta: float):
	if not enabled:
		return
	
	# æ›´æ–°æ‰€æœ‰åå­—æ•°æ®
	for name_label in _name_labels:
		name_label.update_data()
	
	queue_redraw()

func _draw():
	for name_label in _name_labels:
		if name_label.is_visible and name_label.should_show_name:
			_draw_single_name_label(name_label)

func _draw_single_name_label(name_label: NameLabelData):
	var screen_pos = name_label.world_position
	
	var health_bar_y_offset = -60 if name_label.entity_type == "player" else -40
	
	# ğŸ¯ åå­—åœ¨è¡€æ¡ä¸‹æ–¹ï¼ˆè¡€æ¡é«˜åº¦6 + é—´è·ï¼‰
	screen_pos.y += health_bar_y_offset + 30  # è¡€æ¡ä¸‹æ–¹10åƒç´ 
	
	var font_size = 12
	var text = name_label.entity_name
	var health_bar_width = 50
	
	# ä½¿ç”¨è¡€æ¡å®½åº¦å±…ä¸­
	var text_pos = Vector2(
		screen_pos.x - health_bar_width / 2.0,
		screen_pos.y
	)
	
	var name_color = Color.RED if name_label.entity_type == "boss" else Color.WHITE
	
	# é»‘è‰²æè¾¹
	draw_string(_font, text_pos + Vector2(-1, 0), text, HORIZONTAL_ALIGNMENT_CENTER, health_bar_width, font_size, Color.BLACK)
	draw_string(_font, text_pos + Vector2(1, 0), text, HORIZONTAL_ALIGNMENT_CENTER, health_bar_width, font_size, Color.BLACK)
	draw_string(_font, text_pos + Vector2(0, -1), text, HORIZONTAL_ALIGNMENT_CENTER, health_bar_width, font_size, Color.BLACK)
	draw_string(_font, text_pos + Vector2(0, 1), text, HORIZONTAL_ALIGNMENT_CENTER, health_bar_width, font_size, Color.BLACK)
	
	# ä¸»ä½“æ–‡å­—
	draw_string(_font, text_pos, text, HORIZONTAL_ALIGNMENT_CENTER, health_bar_width, font_size, name_color)

func _draw_name_with_outline(txt_name: String, pos: Vector2, text_color: Color, font_size: int):
	var outline_offset = 1
	
	# é»‘è‰²æè¾¹
	draw_string(_font, pos + Vector2(-outline_offset, 0), txt_name, HORIZONTAL_ALIGNMENT_LEFT, -1, font_size, Color.BLACK)
	draw_string(_font, pos + Vector2(outline_offset, 0), txt_name, HORIZONTAL_ALIGNMENT_LEFT, -1, font_size, Color.BLACK)
	draw_string(_font, pos + Vector2(0, -outline_offset), txt_name, HORIZONTAL_ALIGNMENT_LEFT, -1, font_size, Color.BLACK)
	draw_string(_font, pos + Vector2(0, outline_offset), txt_name, HORIZONTAL_ALIGNMENT_LEFT, -1, font_size, Color.BLACK)
	
	# ä¸»ä½“æ–‡å­—
	draw_string(_font, pos, txt_name, HORIZONTAL_ALIGNMENT_LEFT, -1, font_size, text_color)

# ğŸ†• å¼ºåˆ¶æ˜¾ç¤ºæŸä¸ªå®ä½“çš„åå­—ï¼ˆç”¨äºç‰¹æ®Šæƒ…å†µä¸‹ï¼‰
func force_show_name(entity: GameEntity, show_name: bool = true):
	for name_label in _name_labels:
		if name_label.entity == entity:
			name_label.should_show_name = show_name
			break

# è°ƒè¯•ä¿¡æ¯
func get_system_info() -> Dictionary:
	var info = super.get_system_info()
	info["name_label_count"] = _name_labels.size()
	
	# ç»Ÿè®¡æ˜¾ç¤ºä¸­çš„åå­—æ•°é‡
	var showing_count = 0
	for name_label in _name_labels:
		if name_label.should_show_name:
			showing_count += 1
	info["showing_name_count"] = showing_count
	
	return info


==== res:///core/ecs/systems/system_base.gd ====
# res://core/ecs/systems/system_base.gd
# è®¾è®¡åŸåˆ™ï¼š
#   - æ— çŠ¶æ€ï¼šç³»ç»Ÿæœ¬èº«ä¸å­˜å‚¨ä¸šåŠ¡æ•°æ®ï¼Œåªå¤„ç†EntityData
#   - å•ä¸€èŒè´£ï¼šæ¯ä¸ªç³»ç»Ÿåªè´Ÿè´£ä¸€ä¸ªç‰¹å®šçš„åŠŸèƒ½é¢†åŸŸ
#   - æ‰¹é‡å¤„ç†ï¼šæ”¯æŒæŒ‰æ‰¹å¤„ç†å®ä½“ï¼Œä¼˜åŒ–æ€§èƒ½
class_name SystemBase extends Node2D

# ç³»ç»Ÿå…³æ³¨çš„å®ä½“åˆ—è¡¨
var entities: Array[GameEntity] = []

# ç³»ç»Ÿé…ç½®
var update_priority: int = 0          # æ›´æ–°ä¼˜å…ˆçº§ï¼ˆæ•°å€¼è¶Šå°è¶Šå…ˆæ‰§è¡Œï¼‰
var enabled: bool = true              # ç³»ç»Ÿæ˜¯å¦å¯ç”¨

# æ‰¹å¤„ç†é…ç½®
var use_batch_processing: bool = true # æ˜¯å¦å¯ç”¨åˆ†æ‰¹å¤„ç†
var batch_size: int = 20              # æ¯æ‰¹å¤„ç†çš„å®ä½“æ•°é‡
var batch_threshold: int = 50         # å¯ç”¨åˆ†æ‰¹çš„å®ä½“æ•°é‡é˜ˆå€¼
var _current_batch_index: int = 0     # å½“å‰æ‰¹å¤„ç†ä½ç½®

# ç³»ç»Ÿæ ‡è¯†
var system_name: String = "UnnamedSystem"
var system_type: String = "Generic"    # Core, Gameplay, Render, Infrastructure

# è™šå‡½æ•°ï¼šç³»ç»Ÿåˆå§‹åŒ–
func _initialize() -> void:
	# ç³»ç»Ÿåˆå§‹åŒ–ï¼Œåœ¨æ·»åŠ åˆ°SystemManageræ—¶è°ƒç”¨
	print("ç³»ç»Ÿåˆå§‹åŒ–: ", system_name)
	pass

# è™šå‡½æ•°ï¼šç³»ç»Ÿæ¸…ç†
func _shutdown() -> void:
	# ç³»ç»Ÿæ¸…ç†ï¼Œåœ¨ä»SystemManagerç§»é™¤æ—¶è°ƒç”¨
	print("ç³»ç»Ÿå…³é—­: ", system_name)
	entities.clear()
	_current_batch_index = 0

# ä¸»æ›´æ–°å‡½æ•° - ç”±SystemManageræ¯å¸§è°ƒç”¨
func process_system(delta: float) -> void:
	# ç³»ç»Ÿä¸»æ›´æ–°å‡½æ•°
	if not enabled or entities.is_empty():
		return
	
	# æ ¹æ®é˜ˆå€¼å†³å®šæ˜¯å¦å¯ç”¨åˆ†æ‰¹å¤„ç†
	if use_batch_processing and entities.size() > batch_threshold:
		_process_with_batching(delta)
	else:
		_process_all_entities(delta)

# åˆ†æ‰¹å¤„ç†æ¨¡å¼
func _process_with_batching(delta: float) -> void:
	# åˆ†æ‰¹å¤„ç†å®ä½“
	var start_idx = _current_batch_index
	var end_idx = min(start_idx + batch_size, entities.size())
	
	# å¤„ç†å½“å‰æ‰¹æ¬¡
	for i in range(start_idx, end_idx):
		var entity = entities[i]
		if entity and entity.is_entity_active():
			# â›” ä¸ç¬¦åˆæ¡ä»¶ç›´æ¥èµ°äºº
			if not _should_process_entity(entity):
				continue
			_process_entity(entity, delta)
	
	# æ›´æ–°æ‰¹å¤„ç†ä½ç½®ï¼ˆå¾ªç¯ï¼‰
	_current_batch_index = end_idx
	if _current_batch_index >= entities.size():
		_current_batch_index = 0

# å…¨é‡å¤„ç†æ¨¡å¼
func _process_all_entities(delta: float) -> void:
	# å…¨é‡å¤„ç†æ‰€æœ‰å®ä½“
	for entity in entities:
		if entity and entity.is_entity_active():
			# â›” ä¸ç¬¦åˆæ¡ä»¶ç›´æ¥èµ°äºº
			if not _should_process_entity(entity):
				continue
			_process_entity(entity, delta)

# å­ç±»é‡å†™æ­¤å‡½æ•°å³å¯ï¼Œé»˜è®¤å…¨é€šè¿‡
func _should_process_entity(_entity: GameEntity) -> bool:
	return true
	
# è™šå‡½æ•°ï¼šå¤„ç†å•ä¸ªå®ä½“
func _process_entity(_entity: GameEntity, _delta: float) -> void:
	# å¤„ç†å•ä¸ªå®ä½“ï¼ˆå­ç±»å¿…é¡»é‡å†™æ­¤æ–¹æ³•ï¼‰
	push_error("SystemBase._process_entity() å¿…é¡»è¢«å­ç±»é‡å†™: ", system_name)

# å®ä½“ç®¡ç†
func register_entity(entity: GameEntity) -> void:
	# å‘ç³»ç»Ÿæ³¨å†Œå®ä½“
	if entity and not entities.has(entity):
		entities.append(entity)
		_on_entity_registered(entity)

func unregister_entity(entity: GameEntity) -> void:
	# ä»ç³»ç»Ÿæ³¨é”€å®ä½“
	if entities.has(entity):
		entities.erase(entity)
		_on_entity_unregistered(entity)
		# å¦‚æœåˆ é™¤çš„å®ä½“åœ¨_current_batch_indexä¹‹å‰ï¼Œéœ€è¦è°ƒæ•´ç´¢å¼•
		if entities.size() > 0 and _current_batch_index >= entities.size():
			_current_batch_index = 0

func clear_entities() -> void:
	# æ¸…ç©ºæ‰€æœ‰å®ä½“
	for entity in entities:
		_on_entity_unregistered(entity)
	entities.clear()
	_current_batch_index = 0

# å®ä½“äº‹ä»¶å›è°ƒ
func _on_entity_registered(entity: GameEntity) -> void:
	# å®ä½“æ³¨å†Œæ—¶çš„å›è°ƒ
	print("å®ä½“æ³¨å†Œåˆ°ç³»ç»Ÿ: ", system_name, " - ", entity.data.config.entity_name)

func _on_entity_unregistered(entity: GameEntity) -> void:
	# å®ä½“æ³¨é”€æ—¶çš„å›è°ƒ
	print("å®ä½“ä»ç³»ç»Ÿæ³¨é”€: ", system_name, " - ", entity.data.config.entity_name)

# ç³»ç»ŸçŠ¶æ€æ§åˆ¶
func enable() -> void:
	# å¯ç”¨ç³»ç»Ÿ
	if not enabled:
		enabled = true
		print("ç³»ç»Ÿå¯ç”¨: ", system_name)

func disable() -> void:
	# ç¦ç”¨ç³»ç»Ÿ
	if enabled:
		enabled = false
		print("ç³»ç»Ÿç¦ç”¨: ", system_name)

func toggle_enabled() -> bool:
	# åˆ‡æ¢ç³»ç»Ÿå¯ç”¨çŠ¶æ€
	enabled = not enabled
	print("ç³»ç»ŸçŠ¶æ€åˆ‡æ¢: ", system_name, " -> ", enabled)
	return enabled

# æ‰¹å¤„ç†é…ç½®æ–¹æ³•
func set_batch_settings(use_batch: bool, threshold: int, size: int) -> void:
	# è®¾ç½®æ‰¹å¤„ç†å‚æ•°
	use_batch_processing = use_batch
	batch_threshold = max(1, threshold)
	batch_size = max(1, size)
	print("æ‰¹å¤„ç†è®¾ç½®æ›´æ–°: ", system_name, " é˜ˆå€¼=", threshold, " æ‰¹å¤§å°=", size)

func disable_batching() -> void:
	# ç¦ç”¨æ‰¹å¤„ç†
	use_batch_processing = false
	print("æ‰¹å¤„ç†å·²ç¦ç”¨: ", system_name)

# å·¥å…·å‡½æ•°
func get_entity_count() -> int:
	# è·å–å½“å‰ç®¡ç†çš„å®ä½“æ•°é‡
	return entities.size()

func is_system_processing() -> bool:
	# æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦æ­£åœ¨å¤„ç†ï¼ˆå¯ç”¨ä¸”æœ‰å®ä½“ï¼‰
	return enabled and not entities.is_empty()

func get_batch_info() -> Dictionary:
	# è·å–æ‰¹å¤„ç†ä¿¡æ¯
	return {
		"use_batch_processing": use_batch_processing,
		"batch_threshold": batch_threshold,
		"batch_size": batch_size,
		"current_batch_index": _current_batch_index,
		"is_using_batch": use_batch_processing and entities.size() > batch_threshold
	}

func get_system_info() -> Dictionary:
	# è·å–ç³»ç»Ÿä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
	return {
		"name": system_name,
		"type": system_type,
		"enabled": enabled,
		"entity_count": entities.size(),
		"priority": update_priority,
		"batch_info": get_batch_info()
	}

# è°ƒè¯•åŠŸèƒ½
func print_debug_info() -> void:
	# æ‰“å°ç³»ç»Ÿè°ƒè¯•ä¿¡æ¯
	var info = get_system_info()
	print("=== ç³»ç»Ÿè°ƒè¯•ä¿¡æ¯ ===")
	for key in info:
		if key != "batch_info":
			print("  ", key, ": ", info[key])
	
	var batch_info = info["batch_info"]
	print("  æ‰¹å¤„ç†ä¿¡æ¯:")
	for key in batch_info:
		print("    ", key, ": ", batch_info[key])
	
	print("  å®ä½“åˆ—è¡¨:")
	for entity in entities:
		if entity and entity.data:
			print("    - ", entity.data.config.entity_name)


==== res:///exported_scripts.gd ====
@tool
extends EditorScript

const EXPORT_FILE := "exported_scripts.txt"

func _init() -> void:
	# 1) å¯¼å‡ºæ‰€æœ‰ .gd æ–‡ä»¶
	_export_all_scripts()
	

# ---------- 1. å¯¼å‡ºè„šæœ¬ ----------
func _export_all_scripts() -> void:
	var files := _list_all_gd_files("res://")
	var content := ""
	for path in files:
		var file := FileAccess.open(path, FileAccess.READ)
		if file:
			content += "\n\n==== %s ====\n" % path
			content += file.get_as_text()
			file.close()
	var out := FileAccess.open(EXPORT_FILE, FileAccess.WRITE)
	out.store_string(content)
	out.close()
	print("ğŸ“ å·²å¯¼å‡º %d ä¸ªè„šæœ¬ -> %s" % [files.size(), EXPORT_FILE])

# é€’å½’æ”¶é›† .gd
func _list_all_gd_files(dir: String) -> PackedStringArray:
	var list := PackedStringArray()
	var dir_access := DirAccess.open(dir)
	if dir_access:
		dir_access.list_dir_begin()
		var name := dir_access.get_next()
		while name != "":
			var full := dir + "/" + name
			if dir_access.current_is_dir() and not name.begins_with("."):
				list.append_array(_list_all_gd_files(full))
			elif name.ends_with(".gd"):
				list.append(full)
			name = dir_access.get_next()
	return list


==== res:///global/data/gameplay_session_data..gd ====
# æ–°å»º gameplay_session_data.gd
class_name GameplaySessionData extends Resource

# æˆ˜æ–—ç›¸å…³çŠ¶æ€
var auto_battle: bool = false
var current_battle_mode: int = 0  # ä½¿ç”¨BattleModeæšä¸¾
var last_combat_time: float = 0.0
var preferred_skills: Array[String] = []

# åœ°å›¾æ¢ç´¢çŠ¶æ€
var discovered_areas: Array[String] = []
var current_quests: Array[String] = []

# ç•Œé¢çŠ¶æ€
var ui_layout_preferences: Dictionary = {}
var quick_slot_settings: Dictionary = {}

func serialize() -> Dictionary:
	return {
		"auto_battle": auto_battle,
		"current_battle_mode": current_battle_mode,
		"discovered_areas": discovered_areas
	}

func deserialize(data: Dictionary):
	auto_battle = data.get("auto_battle", false)
	current_battle_mode = data.get("current_battle_mode", 0)
	discovered_areas = data.get("discovered_areas", [])


==== res:///global/data/player_skill_data.gd ====
# res://autoload/data/player_skill_data.gd
class_name PlayerSkillData extends Resource

# ğŸ¯ çº¯æ•°æ®å®¹å™¨ï¼Œæ²¡æœ‰ä»»ä½•é€»è¾‘æ–¹æ³•
var skills: Dictionary = {}  # skill_id -> {"current_level": int, "experience": int, "last_used_time": float}

# ğŸ¯ åªæœ‰åºåˆ—åŒ–æ–¹æ³•ï¼ˆæ•°æ®è½¬æ¢ï¼Œä¸ç®—ä¸šåŠ¡é€»è¾‘ï¼‰
func serialize() -> Dictionary:
	return skills.duplicate(true)

func deserialize(data: Dictionary):
	skills = data.duplicate(true)


==== res:///global/data/scene_navigation_data.gd ====
# scene_navigation_data.gd
class_name SceneNavigationData extends Resource

# ğŸ¯ ç©å®¶çœŸå®ä½ç½®ï¼ˆæŒä¹…åŒ–ï¼‰
var persistent_position: Vector2 = Vector2.ZERO 	# çœŸå®æ¸¸æˆä½ç½®
var persistent_scene_id: String = "map_001"     	# çœŸå®æ‰€åœ¨åœºæ™¯id

# ğŸ¯ åœºæ™¯ä¼ é€æ•°æ®ï¼ˆä¸´æ—¶ï¼‰
var transition_data: Dictionary = {
	"from_scene_id": "",           # æ¥æºåœºæ™¯
	"from_exit_id": "",            # æ¥æºå‡ºå£ID  
	"to_scene_id": "",             # ç›®æ ‡åœºæ™¯
	"to_spawn_id": "",             # ç›®æ ‡å‡ºç”Ÿç‚¹ID
	"transition_type": "normal"    # ä¼ é€ç±»å‹
}

# ğŸ¯ åºåˆ—åŒ–ï¼ˆåªå­˜çœŸå®ä½ç½®ï¼‰
func serialize() -> Dictionary:
	return {
		"persistent_scene_id": persistent_scene_id,
		"persistent_position": {"x": persistent_position.x, "y": persistent_position.y}
	}

# ğŸ¯ ååºåˆ—åŒ–
func deserialize(data: Dictionary):
	persistent_scene_id = data.get("persistent_scene_id", "")
	var pos_data = data.get("persistent_position", {})
	persistent_position = Vector2(pos_data.get("x", 0), pos_data.get("y", 0))

# ğŸ¯ è®¾ç½®ä¼ é€ä¿¡æ¯
func set_transition(from_scene: String, from_exit: String, to_scene: String, to_spawn: String, type: String = "normal"):
	transition_data = {
		"from_scene_id": from_scene,
		"from_exit_id": from_exit,
		"to_scene_id": to_scene, 
		"to_spawn_id": to_spawn,
		"transition_type": type
	}

# ğŸ¯ è·å–ç›®æ ‡å‡ºç”Ÿç‚¹ï¼ˆä»åœ°å›¾é…ç½®è¯»å–ï¼‰
func get_target_spawn_position() -> Vector2:
	var spawn_id = transition_data.get("to_spawn_id", "")
	var scene_id = transition_data.get("to_scene_id", "")
	
	# ğŸ¯ ä»åœ°å›¾é…ç½®è·å–å‡ºç”Ÿç‚¹
	var map_config = Game.config_manager.map_templates.get(scene_id, {})
	var spawn_points = map_config.get("spawn_points", {})
	
	return spawn_points.get(spawn_id, Vector2(300, 300))

# ğŸ¯ æ›´æ–°çœŸå®ä½ç½®ï¼ˆé€€å‡ºæ¸¸æˆæ—¶è°ƒç”¨ï¼‰
func update_persistent_position(scene_id: String, position: Vector2):
	persistent_scene_id = scene_id
	persistent_position = position


==== res:///global/data/user_profile_data.gd ====
# user_profile_data.gd
class_name UserProfileData extends Resource

var user_id: int = 0
var zone_id: int = 0

var level: int = 1
var experience: int = 0
var nickname: String = "æœªçŸ¥ç©å®¶"
var last_activity: float = 0
var total_play_time: float = 0

# æ–°å¢å­—æ®µ
var gender: int = 0  # 0=æœªé€‰æ‹© 1=ç”· 2=å¥³
var job: int = 0     # 0=æœªé€‰æ‹© 1=æˆ˜å£« 2=æ³•å¸ˆ 3=é“å£«  
var created_at: float = 0  # è§’è‰²åˆ›å»ºæ—¶é—´

func deserialize(data: Dictionary) -> void:
	if data.has("user_id"): user_id = data["user_id"]
	if data.has("zone_id"): zone_id = data["zone_id"]
	if data.has("level"): level = data["level"]
	if data.has("experience"): experience = data["experience"]
	if data.has("nickname"): nickname = data["nickname"]
	if data.has("last_activity"): last_activity = data["last_activity"]
	if data.has("total_play_time"): total_play_time = data["total_play_time"]
	
	# æ–°å¢å­—æ®µ
	if data.has("gender"): gender = data["gender"]
	if data.has("job"): job = data["job"]
	if data.has("created_at"): created_at = data["created_at"]

func serialize() -> Dictionary:
	return {
		"user_id": user_id,
		"zone_id": zone_id,
		"level": level,
		"experience": experience,
		"nickname": nickname,
		"last_activity": last_activity,
		"total_play_time": total_play_time,
		"gender": gender,
		"job": job,
		"created_at": created_at
	}

# æ–°å¢å·¥å…·æ–¹æ³•
func get_job_name() -> String:
	match job:
		1: return "æˆ˜å£«"
		2: return "æ³•å¸ˆ"
		3: return "é“å£«"
		_: return "æœªé€‰æ‹©"

func get_gender_name() -> String:
	match gender:
		1: return "ç”·"
		2: return "å¥³"
		_: return "æœªé€‰æ‹©"

func is_new_character() -> bool:
	# 3å¤©å†…åˆ›å»ºçš„è§’è‰²ç®—æ–°è§’è‰²
	var three_days_ago = Time.get_unix_time_from_system() - (3 * 24 * 60 * 60)
	return created_at > three_days_ago

func get_character_age_days() -> int:
	# è§’è‰²åˆ›å»ºäº†å¤šå°‘å¤©
	return int((Time.get_unix_time_from_system() - created_at) / (24 * 60 * 60))

func set_job(new_job: int) -> void:
	job = new_job

func set_gender(new_gender: int) -> void:
	gender = new_gender


==== res:///global/entity_registry.gd ====
# res://core/ecs/world/entity_registry.gd
# å•ä¾‹
# ç±»åï¼šEntityRegistry
# ä½œç”¨ï¼šå®ä½“æ³¨å†Œè¡¨ï¼Œç®¡ç†æ‰€æœ‰æ´»è·ƒå®ä½“
# èŒè´£ï¼š
#   - æ³¨å†Œå’Œæ³¨é”€å®ä½“åˆ°ECSç³»ç»Ÿ
#   - æä¾›å®ä½“æŸ¥è¯¢åŠŸèƒ½
#   - ç®¡ç†å®ä½“ç”Ÿå‘½å‘¨æœŸ
extends Node


# å®ä½“å­˜å‚¨
var _entities: Dictionary = {}  # entity_id -> GameEntity
var _entities_by_type: Dictionary = {}  # entity_type -> Array[GameEntity]

# æ³¨å†Œå®ä½“åˆ°ECSç³»ç»Ÿ
func register_entity(entity: GameEntity) -> bool:
	var entity_data = entity.get_entity_data()
	var entity_id = entity_data.config.entity_id
	var entity_type = entity_data.config.entity_type
	
	if _entities.has(entity_id):
		push_error("å®ä½“å·²å­˜åœ¨: " + entity_id)
		return false
	
	# å­˜å‚¨å®ä½“
	_entities[entity_id] = entity
	
	# æŒ‰ç±»å‹åˆ†ç±»
	if not _entities_by_type.has(entity_type):
		_entities_by_type[entity_type] = []
	_entities_by_type[entity_type].append(entity)
	
	# æ³¨å†Œåˆ°æ‰€æœ‰ç³»ç»Ÿ
	SystemManager.register_entity_to_systems(entity)
	
	print("âœ… å®ä½“æ³¨å†ŒæˆåŠŸ: %s (%s)" % [entity_data.config.entity_name, entity_id])
	return true

# æ³¨é”€å®ä½“
func unregister_entity(entity: GameEntity) -> bool:
	var entity_data = entity.get_entity_data()
	var entity_id = entity_data.config.entity_id
	var entity_type = entity_data.config.entity_type
	
	if not _entities.has(entity_id):
		push_error("å®ä½“ä¸å­˜åœ¨: " + entity_id)
		return false
	
	# ä»æ‰€æœ‰ç³»ç»Ÿæ³¨é”€
	SystemManager.unregister_entity_from_systems(entity)
	
	# ä»å­˜å‚¨ä¸­ç§»é™¤
	_entities.erase(entity_id)
	if _entities_by_type.has(entity_type):
		_entities_by_type[entity_type].erase(entity)
	
	print("ğŸ—‘ï¸ å®ä½“æ³¨é”€: %s (%s)" % [entity_data.config.entity_name, entity_id])
	return true

# å®ä½“æŸ¥è¯¢
func get_entity(entity_id: String) -> GameEntity:
	return _entities.get(entity_id)

func get_entities_by_type(entity_type: String) -> Array:
	return _entities_by_type.get(entity_type, []).duplicate()

func get_all_entities() -> Array:
	return _entities.values()

# è·å–å®ä½“æ•°é‡ç»Ÿè®¡
func get_entity_stats() -> Dictionary:
	var stats = {"total": _entities.size()}
	for entity_type in _entities_by_type:
		stats[entity_type] = _entities_by_type[entity_type].size()
	return stats

# è°ƒè¯•åŠŸèƒ½
func print_entity_stats():
	var stats = get_entity_stats()
	print("=== å®ä½“ç»Ÿè®¡ ===")
	print("æ€»å®ä½“æ•°: ", stats.total)
	for entity_type in _entities_by_type:
		print("  %s: %d" % [entity_type, _entities_by_type[entity_type].size()])


==== res:///global/game.gd ====
extends Node

const SHARED_CIRCLE_44 = preload("uid://ljqm0hcpijnt")
const SHARED_CIRCLE_72 = preload("uid://dlwg14a8t4brl")
const SHARED_CIRCLE_108 = preload("uid://cgqk4mwv7hg0i")

# é»˜è®¤ç³»ç»Ÿæ³¨å†Œé…ç½®
var system_registrations: Array = [
	 {
		"script": load("res://core/ecs/systems/infrastructure/touch_input_system.gd"),
		"group": "infrastructure",
		"name": "TouchInputSystem",
		"needs_scene_tree": true, 
		"priority": 1  # è¾“å…¥ç³»ç»Ÿä¼˜å…ˆçº§æœ€é«˜
	},
	{
		"script": load("res://core/ecs/systems/core/movement_system.gd"),
		"group": "core",
		"name": "MovementSystem",
		"needs_scene_tree": false, 
		"priority": 10  
	},
	{
		"script": load("res://core/ecs/systems/infrastructure/camera_system.gd"),
		"group": "infrastructure",
		"name": "CameraSystem",
		"needs_scene_tree": true, 
		"priority": 90  
	},
	{
		"script": load("res://core/ecs/systems/render/health_bar_system.gd"),
		"group": "infrastructure",
		"name": "HealthBarSystem",
		"needs_scene_tree": true, 
		"priority": 95  
	},
	{
		"script": load("res://core/ecs/systems/render/name_label_system.gd"),
		"group": "infrastructure",
		"name": "NameLabelSystem",
		"needs_scene_tree": true, 
		"priority": 96 
	},
]

## å•ä¾‹ Game
enum GameMode {
	OFFLINE = 1,
	ONLINE = 2
}

var game_mode: GameMode = GameMode.OFFLINE

var _save_load_manager:SaveLoadManager = SaveLoadManager.new()
var has_valid_save: bool = false

var config_manager:ConfigManager
var data:DataManager

@onready var color_rect: ColorRect = $TransitionCanvas/ColorRect

func _init() -> void:
	data = DataManager.new()
	config_manager = ConfigManager.new()
	
	
func _ready():
	print("ğŸ® æ¸¸æˆåˆå§‹åŒ–å®Œæˆ - æ¨¡å¼: %s" % ("è”æœº" if game_mode == GameMode.ONLINE else "å•æœº"))
	load_data()

func save_data() -> bool:
	# ä»SystemåŒæ­¥åˆ°data
	
	var game_data := get_save_data()
	var success = _save_load_manager.save_game(game_data)
	has_valid_save = success
	return success
	
func load_data() -> bool:
	var getted_data = _save_load_manager.load_game()
	has_valid_save = not getted_data.is_empty()

	if has_valid_save:
		apply_loaded_data(getted_data)
	
	return has_valid_save

func get_save_data() -> Dictionary:
	return {
		"data":data.to_dict(),
		"timestamp": Time.get_unix_time_from_system()
	}

func apply_loaded_data(getted_data:Dictionary) -> void:
	print(getted_data)
	data.from_dict(getted_data["data"])
		
# ==================== å…¬å¼€æ¥å£ ====================

# UIåœºæ™¯åˆ‡æ¢ï¼ˆç®€å•ç‰ˆï¼‰
func change_ui_scene(scene_path: String, transition_params: Dictionary = {}) -> void:
	print("ğŸ–¥ï¸ UIåœºæ™¯åˆ‡æ¢: ", scene_path)
	
	var duration = transition_params.get("duration", 0.3)
	
	# 1. æš‚åœ + æ·¡å…¥
	get_tree().paused = true
	await _fade_in(duration)
	
	# 2. ç›´æ¥åˆ‡æ¢åœºæ™¯ï¼ˆUIåœºæ™¯æ²¡æœ‰ECSå®ä½“ï¼‰
	get_tree().change_scene_to_file(scene_path)
	await get_tree().tree_changed
	
	# 3. æ¢å¤ + æ·¡å‡º
	get_tree().paused = false
	await _fade_out(duration)
	
	print("âœ… UIåœºæ™¯åˆ‡æ¢å®Œæˆ")

# æ¸¸æˆåœºæ™¯åˆ‡æ¢ï¼ˆå®Œæ•´ç‰ˆï¼‰
func change_game_scene(scene_path: String, game_params: Dictionary = {}) -> void:
	var duration = game_params.get("transition_duration", 0.2)
	
	# 1. æš‚åœ + æ·¡å…¥
	get_tree().paused = true
	await _fade_in(duration)
	
	# 4. åˆ‡æ¢åœºæ™¯
	get_tree().change_scene_to_file(scene_path)
	await get_tree().tree_changed
	
	# 8. æ¢å¤ + æ·¡å‡º
	get_tree().paused = false
	await _fade_out(duration)
	
	print("âœ… æ¸¸æˆåœºæ™¯åˆ‡æ¢å®Œæˆ")

# ==================== å†…éƒ¨æ–¹æ³• ====================
# æ·¡å…¥è¿‡æ¸¡
func _fade_in(duration: float) -> void:
	var tween := create_tween()
	tween.set_pause_mode(Tween.TWEEN_PAUSE_PROCESS)
	tween.tween_property(color_rect, "color:a", 1.0, duration)
	await tween.finished

# æ·¡å‡ºè¿‡æ¸¡
func _fade_out(duration: float) -> void:
	var tween := create_tween()
	tween.set_pause_mode(Tween.TWEEN_PAUSE_PROCESS)
	tween.tween_property(color_rect, "color:a", 0.0, duration)
	await tween.finished


==== res:///global/managers/config_manager.gd ====
extends RefCounted
class_name ConfigManager

const PATH :String = "res://database/"
const LOADKEY:String = "E3967DFBABC33E7A945DD46E2816E5"

var file_list:Array = [
		"item_templates",
		"monster_templates",
		"skill_templates",
		"map_templates",
		"player_templates",
		"skill_levels_templates",
	]
	
var item_templates:Dictionary = {}
var monster_templates:Dictionary = {}
var skill_templates:Dictionary = {}
var map_templates:Dictionary = {}
var player_templates:Dictionary = {}
var skill_levels_templates:Dictionary = {}

func _init() -> void:
	for file_name in file_list:
		_load_data(file_name)
	
func _load_data(file_name:String) -> void:
	var _path:String = PATH + file_name + ".json"
	var file := FileAccess.open_encrypted_with_pass(_path,FileAccess.READ,LOADKEY)
	if file:
		var content := file.get_as_text()
		file.close()
		self[file_name] = _array_data_to_json(JSON.parse_string(content))
		
func _array_data_to_json(array:Array) -> Dictionary:
	var json_data:Dictionary = {}
	for data in array:
		json_data[data.id] = data
	return json_data


==== res:///global/managers/data_manager.gd ====
# data_manager.gd
class_name DataManager extends RefCounted

# æ‰€æœ‰æ•°æ®ç±»åœ¨è¿™é‡Œç»Ÿä¸€ç®¡ç†
#var user: UserData
var profile: UserProfileData
#var zone: ZoneData  
#var chat: ChatData
#var mail_list: MailListData  # æ”¹ä¸ºé‚®ä»¶åˆ—è¡¨
#var vip: VipData
#var session: SessionData
#var settings: GameSettings
#var wallet:WalletData
#var task_list:TaskListData
#var inventory:NetInventoryData
var player_skills: PlayerSkillData  # ğŸ†• çº¯æ•°æ®å®¹å™¨

# ğŸ¯ åœºæ™¯å¯¼èˆªæ•°æ®
var scene_navigation: SceneNavigationData
var gameplay_session_data: GameplaySessionData
# ğŸ¯ æ¸¸æˆè®¾ç½®
#var settings: GameSettings

# èŠå¤©å®¤
var chat_messages: Dictionary = {}  # channel_type -> Array[ChatMessageData]
var current_channel: int = 1  # å½“å‰é€‰ä¸­çš„é¢‘é“

func _init():
	#user = UserData.new()
	profile = UserProfileData.new()
	#zone = ZoneData.new()
	#chat = ChatData.new()
	#mail_list = MailListData.new()
	#vip = VipData.new()
	#session = SessionData.new()
	#settings = GameSettings.new()
	#wallet = WalletData.new()
	#task_list = TaskListData.new()
	#inventory = NetInventoryData.new()
	scene_navigation = SceneNavigationData.new()
	gameplay_session_data = GameplaySessionData.new()
	player_skills = PlayerSkillData.new()

func to_dict() -> Dictionary:
	return {
		#"user":user.to_dict(),
		"profile":profile.serialize(),
		"scene_navigation":scene_navigation.serialize(),
		"gameplay_session_data":gameplay_session_data.serialize(),
		"player_skills": player_skills.serialize()
	}

func from_dict(save_data:Dictionary) -> void:
	if save_data.is_empty(): return
	#if save_data.has("user"): user.update_from_dict(save_data["user"])
	if save_data.has("profile"): profile.deserialize(save_data["profile"])
	if save_data.has("scene_navigation"): scene_navigation.deserialize(save_data["scene_navigation"])
	if save_data.has("gameplay_session_data"): gameplay_session_data.deserialize(save_data["gameplay_session_data"])
	if save_data.has("player_skills"): player_skills.deserialize(save_data["player_skills"])

## ğŸ†• åˆå§‹åŒ–æ–°æ¸¸æˆæ•°æ®
func initialize_new_game():
	profile.level = 1
	profile.experience = 0
	profile.nickname = "æ–°æ‰‹ç©å®¶"
	profile.gender = 0
	profile.job = 0
	profile.created_at = Time.get_unix_time_from_system()
	
	# åˆå§‹åŒ–åœºæ™¯å¯¼èˆªæ•°æ®
	scene_navigation.persistent_scene_id = "map_001"
	scene_navigation.persistent_position = Vector2(300, 300)
	
	print("DataManager: æ–°æ¸¸æˆæ•°æ®åˆå§‹åŒ–å®Œæˆ")


==== res:///global/managers/save_load_manager.gd ====
class_name SaveLoadManager extends RefCounted

const SAVE_DIR = "user://saves/"
const POINTER_FILE = "user://save_pointer.dat"
const MAX_SAVES = 5
const SECRET_KEY :String = "Gdot"

var current_pointer :int = 0
var pointer_hash

func _init() -> void:
	# ç¡®ä¿å­˜æ¡£ç›®å½•å­˜åœ¨
	verify_save_directoty(SAVE_DIR)
	# åŠ è½½å½“å‰æŒ‡é’ˆ
	load_pointer()

#éªŒè¯ç›®å½•æ˜¯å¦åˆæ³•
func verify_save_directoty(path:String) -> void:
	DirAccess.make_dir_absolute(path)
	
func save_game(data: Dictionary) -> bool:
	# åˆ›å»ºæ–°çš„å­˜æ¡£æ–‡ä»¶
	var new_save_id = (current_pointer + 1) % MAX_SAVES
	var save_path = SAVE_DIR + "save_" + str(new_save_id) + ".dat"
	
	# å¯†é’¥
	var _s_key :String = OS.get_unique_id() + SECRET_KEY
	# å†™å…¥æ–°çš„å­˜æ¡£æ–‡ä»¶
	var file := FileAccess.open_encrypted_with_pass(save_path,FileAccess.WRITE,_s_key)
	if file:
		# Todo
		var json_string := JSON.stringify(data)
		file.store_string(json_string)
		file.close()
		
		# æ›´æ–°æŒ‡é’ˆ
		# ä½¿ç”¨Cryptoç±»è®¡ç®—SHA256å“ˆå¸Œå€¼
		pointer_hash = json_string.hash()
		current_pointer = new_save_id
		save_pointer()
		return true
	else:
		print("Error saving game: ")
		return false

func load_game() -> Dictionary:
	var data = {}
	
	# ä»æœ€æ–°çš„å­˜æ¡£å¼€å§‹å°è¯•åŠ è½½
	for i in range(MAX_SAVES):
		var save_id = (current_pointer - i + MAX_SAVES) % MAX_SAVES
		var save_path = SAVE_DIR + "save_" + str(save_id) + ".dat"
		
		# å¯†é’¥
		var _s_key :String = OS.get_unique_id() + SECRET_KEY
		
		if FileAccess.file_exists(save_path):
			var file :FileAccess = FileAccess.open_encrypted_with_pass(save_path,FileAccess.READ,_s_key)
			if file:
				var content := file.get_as_text()
				file.close()
				if content.hash() == pointer_hash:
					data = JSON.parse_string(content)
					return data
	
	print("No valid save file found")
	return data

func save_pointer():
	# å†™å…¥æ–°çš„å­˜æ¡£æ–‡ä»¶
	var file := FileAccess.open_encrypted_with_pass(POINTER_FILE,FileAccess.WRITE,OS.get_unique_id())
	if file:
		# Todo
		var json_string := JSON.stringify({"current_pointer":current_pointer,"pointer_hash":pointer_hash})
		file.store_string(json_string)
		file.close()
	else:
		print("Error saving pointer")

func load_pointer():
	if FileAccess.file_exists(POINTER_FILE):
		var file :FileAccess = FileAccess.open_encrypted_with_pass(POINTER_FILE,FileAccess.READ,OS.get_unique_id())
		if file:
			var content := file.get_as_text()
			file.close()
			var data :Dictionary = JSON.parse_string(content)
			if data.has("current_pointer"):
				current_pointer = data.current_pointer
			if data.has("pointer_hash"):
				pointer_hash = data.pointer_hash
		
func clear_all_saves():
	var dir = DirAccess.open(SAVE_DIR)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if dir.current_is_dir():
				print("å‘ç°ç›®å½•ï¼š" + file_name)
			else:
				print("å‘ç°æ–‡ä»¶ï¼š" + file_name)
				dir.remove(SAVE_DIR + file_name)
			file_name = dir.get_next()
	else:
		print("å°è¯•è®¿é—®è·¯å¾„æ—¶å‡ºé”™ã€‚")
	
	# é‡ç½®æŒ‡é’ˆ
	current_pointer = 0
	save_pointer()


==== res:///global/system_manager.gd ====
# res://global/system_manager.gd
extends Node
# ä½œç”¨ï¼šECSæ¶æ„çš„æ ¸å¿ƒè°ƒåº¦å™¨ï¼Œç®¡ç†å’Œåè°ƒæ‰€æœ‰ç³»ç»Ÿçš„æ‰§è¡Œ
# èŒè´£ï¼š
#   - æ³¨å†Œå’Œç®¡ç†æ‰€æœ‰ç³»ç»Ÿå®ä¾‹
#   - æŒ‰ä¼˜å…ˆçº§è°ƒåº¦ç³»ç»Ÿæ‰§è¡Œ
#   - æä¾›ç³»ç»Ÿé—´çš„é€šä¿¡æ¡¥æ¢
#   - æ”¯æŒç³»ç»Ÿçš„åŠ¨æ€å¯ç”¨/ç¦ç”¨

# Godotå•ä¾‹ï¼šä¸éœ€è¦class_nameï¼Œç›´æ¥åœ¨AutoLoadä¸­åŠ è½½

# ç³»ç»Ÿæ³¨å†Œè¡¨
var _systems: Dictionary = {}           # ç³»ç»Ÿåç§° -> ç³»ç»Ÿå®ä¾‹
var _system_instances: Array = []       # æ‰€æœ‰ç³»ç»Ÿå®ä¾‹
var _update_order: Array = []           # æŒ‰ä¼˜å…ˆçº§æ’åºçš„ç³»ç»Ÿåç§°åˆ—è¡¨

# ç³»ç»Ÿç»„åˆ«
var _system_groups: Dictionary = {
	"core": [],        # æ ¸å¿ƒç³»ç»Ÿï¼šç§»åŠ¨ã€æˆ˜æ–—ç­‰
	"gameplay": [],    # ç©æ³•ç³»ç»Ÿï¼šè£…å¤‡ã€æŠ€èƒ½ç­‰  
	"render": [],      # æ¸²æŸ“ç³»ç»Ÿï¼šåŠ¨ç”»ã€UIç­‰
	"infrastructure": [] # åŸºç¡€è®¾æ–½ï¼šç½‘ç»œã€å­˜æ¡£ç­‰
}

# æ€§èƒ½ç›‘æ§
var _performance_counter: int = 0       # æ€§èƒ½ç»Ÿè®¡è®¡æ•°å™¨ï¼ˆ0-60å¾ªç¯ï¼‰
var _system_performance: Dictionary = {} # ç³»ç»Ÿæ€§èƒ½æ•°æ®

var _check_frame:int = 300

# å°±ç»ªå‡½æ•°
func _ready():
	if not Game or not Game.is_node_ready():
		await Game.ready
	print("SystemManager åˆå§‹åŒ–å®Œæˆ")
	_setup_default_systems()
	
# æ¯å¸§æ›´æ–°
func _process(delta: float):
	_performance_counter += 1
	_update_systems(delta)
	
	# æ¯60å¸§è¾“å‡ºä¸€æ¬¡æ€§èƒ½æŠ¥å‘Šå¹¶é‡ç½®
	#if _performance_counter >= _check_frame:
		#_print_performance_report()
		#_reset_performance_counters()
		#_performance_counter = 0

# è®¾ç½®é»˜è®¤ç³»ç»Ÿ
func _setup_default_systems():
	print("å¼€å§‹æ³¨å†Œé»˜è®¤ç³»ç»Ÿ...")
	
	for registration in Game.system_registrations:
		_register_system_internal(registration)
	
	print("é»˜è®¤ç³»ç»Ÿæ³¨å†Œå®Œæˆ")

# å†…éƒ¨ç³»ç»Ÿæ³¨å†Œæ–¹æ³•
func _register_system_internal(registration: Dictionary):
	var system_script = registration.get("script")
	var group = registration.get("group", "core")
	var needs_scene_tree = registration.get("needs_scene_tree", false)
	var priority = registration.get("priority", 50)  # ğŸ¯ è·å–ä¼˜å…ˆçº§
	
	if not system_script:
		push_error("ç³»ç»Ÿæ³¨å†Œç¼ºå°‘script")
		return
	
	var system_instance = system_script.new()
	
	# ğŸ¯ è®¾ç½®ç³»ç»Ÿä¼˜å…ˆçº§
	system_instance.update_priority = priority
	
	if needs_scene_tree:
		add_child(system_instance)
		system_instance.name = registration.get("name", "UnnamedSystem")
		
	if register_system(system_instance, group, needs_scene_tree):
		print("âœ… ç³»ç»Ÿæ³¨å†ŒæˆåŠŸ: ", system_instance.system_name, " ä¼˜å…ˆçº§: ", priority)
	else:
		push_error("âŒ ç³»ç»Ÿæ³¨å†Œå¤±è´¥")

# æ³¨å†Œç³»ç»Ÿ
func register_system(system:SystemBase, group: String = "core", needs_scene_tree: bool = false) -> bool:
	# ç®€å•çš„ç±»å‹æ£€æŸ¥
	if system == null:
		push_error("æ³¨å†Œå¤±è´¥ï¼šç³»ç»Ÿä¸º null")
		return false
	
	# å…ˆåˆå§‹åŒ–ç³»ç»Ÿï¼Œè®©ç³»ç»Ÿè®¾ç½®è‡ªå·±çš„åç§°
	if system.has_method("_initialize"):
		system._initialize()
	
	# åˆå§‹åŒ–åå†è·å–ç³»ç»Ÿåç§°
	var system_name = system.system_name
	print("æ­£åœ¨æ³¨å†Œç³»ç»Ÿ: ", system_name)
	
	if _systems.has(system_name):
		push_error("ç³»ç»Ÿå·²å­˜åœ¨: " + system_name)
		return false
	
	# æ³¨å†Œç³»ç»Ÿ
	_systems[system_name] = system
	_system_instances.append(system)
	
	# æ·»åŠ åˆ°ç»„åˆ«
	if _system_groups.has(group):
		_system_groups[group].append(system_name)
	else:
		_system_groups[group] = [system_name]
	
	# æ›´æ–°æ‰§è¡Œé¡ºåº
	_update_execution_order()
		
	print("ç³»ç»Ÿæ³¨å†ŒæˆåŠŸ: ", system_name, " ç»„åˆ«: ", group)
	
	# é€šçŸ¥å…¶ä»–ç³»ç»Ÿæœ‰æ–°ç³»ç»Ÿæ³¨å†Œ
	_notify_system_registered(system.system_name)
	
	return true

func _notify_system_registered(system_name: String):
	# å…¶ä»–ç³»ç»Ÿå¯ä»¥ç›‘å¬è¿™ä¸ªé€šçŸ¥æ¥æ›´æ–°ä¾èµ–
	for system in _system_instances:
		if system.has_method("_on_system_registered"):
			system._on_system_registered(system_name)
	
# æ³¨é”€ç³»ç»Ÿ
func unregister_system(system_name: String) -> bool:
	if not _systems.has(system_name):
		push_error("ç³»ç»Ÿä¸å­˜åœ¨: " + system_name)
		return false
	
	var system = _systems[system_name]
	
	# æ‰§è¡Œç³»ç»Ÿæ¸…ç†
	if system.has_method("_shutdown"):
		system._shutdown()
	
	# ä»æ‰€æœ‰ç»„åˆ«ä¸­ç§»é™¤
	for group in _system_groups:
		_system_groups[group].erase(system_name)
	
	# ä»æ³¨å†Œè¡¨ä¸­ç§»é™¤
	_systems.erase(system_name)
	_system_instances.erase(system)
	_update_order.erase(system_name)
	
	print("ç³»ç»Ÿæ³¨é”€æˆåŠŸ: ", system_name)
	return true

# è·å–ç³»ç»Ÿ
func get_system(system_name: String):
	return _systems.get(system_name)

# æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å­˜åœ¨
func has_system(system_name: String) -> bool:
	return _systems.has(system_name)

# æ›´æ–°ç³»ç»Ÿæ‰§è¡Œé¡ºåº
func _update_execution_order():
	# æŒ‰ä¼˜å…ˆçº§æ’åº
	_system_instances.sort_custom(_compare_system_priority)
	_update_order.clear()
	
	for system in _system_instances:
		_update_order.append(system.system_name)

# ç³»ç»Ÿä¼˜å…ˆçº§æ¯”è¾ƒå‡½æ•°
func _compare_system_priority(a, b) -> bool:
	return a.update_priority < b.update_priority

# ç³»ç»Ÿæ›´æ–°å¾ªç¯
func _update_systems(delta: float):
	for system_name in _update_order:
		var system = _systems[system_name]
		if system and system.enabled:
			var system_start_time = Time.get_ticks_usec()
			
			# æ‰§è¡Œç³»ç»Ÿæ›´æ–°
			system.process_system(delta)
			
			# è®°å½•æ€§èƒ½æ•°æ®
			var system_time = Time.get_ticks_usec() - system_start_time
			_record_system_performance(system_name, system_time)

# è®°å½•ç³»ç»Ÿæ€§èƒ½
func _record_system_performance(system_name: String, execution_time: int):
	if not _system_performance.has(system_name):
		_system_performance[system_name] = {
			"total_time": 0,
			"max_time": 0,
			"call_count": 0,
			"average_time": 0
		}
	
	var perf = _system_performance[system_name]
	perf.total_time += execution_time
	perf.call_count += 1
	perf.max_time = max(perf.max_time, execution_time)
	perf.average_time = perf.total_time / perf.call_count

# é‡ç½®æ€§èƒ½è®¡æ•°å™¨
func _reset_performance_counters():
	for system_name in _system_performance:
		_system_performance[system_name].call_count = 0
		_system_performance[system_name].total_time = 0

# è¾“å‡ºæ€§èƒ½æŠ¥å‘Š
func _print_performance_report():
	print("=== ç³»ç»Ÿæ€§èƒ½æŠ¥å‘Š (é‡‡æ ·%då¸§) ===" % _check_frame)
	
	var total_system_time = 0
	var has_data = false
	
	for system_name in _system_performance:
		var perf = _system_performance[system_name]
		if perf.call_count > 0:
			has_data = true
			total_system_time += perf.average_time
			print("  %s: å¹³å‡%.2fÎ¼s, æœ€å¤§%dÎ¼s, è°ƒç”¨%dæ¬¡" % [
				system_name, perf.average_time, perf.max_time, perf.call_count
			])
	
	if has_data:
		print("  æ€»ç³»ç»Ÿæ—¶é—´: %.2fÎ¼s" % total_system_time)
		print("  æ´»è·ƒç³»ç»Ÿæ•°é‡: ", _get_active_system_count())
	else:
		print("  æš‚æ— æ€§èƒ½æ•°æ®")

# è·å–æ´»è·ƒç³»ç»Ÿæ•°é‡
func _get_active_system_count() -> int:
	var count = 0
	for system in _system_instances:
		if system.enabled and system.is_system_processing():
			count += 1
	return count

# æŒ‰ç»„åˆ«å¯ç”¨/ç¦ç”¨ç³»ç»Ÿ
func set_group_enabled(group: String, enabled: bool):
	if not _system_groups.has(group):
		push_error("ç³»ç»Ÿç»„åˆ«ä¸å­˜åœ¨: " + group)
		return
	
	for system_name in _system_groups[group]:
		var system = _systems[system_name]
		if system:
			if enabled:
				system.enable()
			else:
				system.disable()

# è·å–ç³»ç»Ÿä¿¡æ¯
func get_system_info() -> Dictionary:
	var info = {
		"total_systems": _system_instances.size(),
		"active_systems": _get_active_system_count(),
		"system_groups": {},
		"performance_data": _system_performance.duplicate()
	}
	
	for group in _system_groups:
		info["system_groups"][group] = _system_groups[group].size()
	
	return info

# è°ƒè¯•åŠŸèƒ½
func print_debug_info():
	var info = get_system_info()
	print("=== SystemManager è°ƒè¯•ä¿¡æ¯ ===")
	print("æ€»ç³»ç»Ÿæ•°é‡: ", info.total_systems)
	print("æ´»è·ƒç³»ç»Ÿæ•°é‡: ", info.active_systems)
	print("ç³»ç»Ÿç»„åˆ«åˆ†å¸ƒ:")
	for group in info.system_groups:
		print("  ", group, ": ", info.system_groups[group])
	
	print("ç³»ç»Ÿæ‰§è¡Œé¡ºåº:")
	for i in range(_update_order.size()):
		var system = _systems[_update_order[i]]
		print("  %d. %s (ä¼˜å…ˆçº§: %d)" % [i + 1, system.system_name, system.update_priority])

# å®ä½“æ³¨å†Œåˆ°æ‰€æœ‰ç›¸å…³ç³»ç»Ÿ
func register_entity_to_systems(entity):
	for system in _system_instances:
		system.register_entity(entity)

# å®ä½“ä»æ‰€æœ‰ç³»ç»Ÿæ³¨é”€
func unregister_entity_from_systems(entity):
	for system in _system_instances:
		system.unregister_entity(entity)


==== res:///scenes/test/test_ecs.gd ====
# test_ecs_scene.gd
extends Node2D

func _ready():
	print("=== GECS æ¡†æ¶é›†æˆæµ‹è¯• ===")
	_test_entity_creation()
	_test_systems()

func _test_entity_creation():
	print("\n1. æµ‹è¯•å®ä½“å·¥å‚...")
	
	# åˆ›å»ºç©å®¶å®ä½“
	var player = EntityFactory.create_player_from_profile(Vector2(100, 200), self)
	if player:
		print("âœ… ç©å®¶åˆ›å»ºæˆåŠŸ:", player.data.config.get_display_name())
		print("   ä½ç½®:", player.position)
		print("   ç”Ÿå‘½å€¼:", player.data.get_health(), "/", player.data.get_max_health())
	
	# åˆ›å»ºæ€ªç‰©å®ä½“
	var monster = EntityFactory.create_monster("1001", Vector2(300, 200), self)
	if monster:
		print("âœ… æ€ªç‰©åˆ›å»ºæˆåŠŸ:", monster.data.config.entity_name)

func _test_systems():
	print("\n2. æµ‹è¯•Systemé›†æˆ...")
	
	# æ£€æŸ¥SystemManagerçŠ¶æ€
	var system_manager = SystemManager
	print("   æ´»è·ƒç³»ç»Ÿ:", system_manager._get_active_system_count())
	
	# æµ‹è¯•EntityRegistry
	print("\n3. æµ‹è¯•EntityRegistry...")
	var registry = EntityRegistry
	registry.print_entity_stats()


==== res:///scenes/ui/startup/startup.gd ====
extends Control


func _on_button_2_pressed() -> void:
	get_tree().quit()


func _on_button_pressed() -> void:
	_goto_game_scene()
	

func _goto_game_scene() -> void:
	# è¿™é‡Œæ˜¯idå­˜çš„ï¼›
	var _scene_id:String = Game.data.scene_navigation.persistent_scene_id
	var _scene_path:String = "res://scenes/maps/%s.tscn" % _scene_id
	_scene_path = "res://scenes/test/test_ecs.tscn"
	Game.change_game_scene(_scene_path,{})
